/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/lodash.debounce/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.debounce/index.js"(exports, module2) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root.Date.now();
    };
    function debounce2(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject2(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike2(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike2(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject2(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject2(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = debounce2;
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => VivaldiNotesPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// setting.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  notesPath: "C:\\Users\\USUARIO\\AppData\\Local\\Vivaldi\\User Data\\Default\\",
  vaultLocation: "/",
  interval: 45e3,
  notesTemplate: "---\nguid: {{VIVALDI_GUID}}\nurl: {{URL}}\ndate_created: {{DATE_CREATED}}\n---\n{{CONTENT}}\n---\n{{IMAGES}}\n\n"
};
var VivaldiNotesSettingtTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Vivaldi Notes Settings" });
    new import_obsidian.Setting(containerEl).setName("Vivaldi notes path Notes Path").setDesc("The path where vivaldi store your notes. You can find it in vivaldi://about/ in the User Profile Path").addText(
      (text) => text.setPlaceholder("C:\\Users\\USUARIO\\AppData\\Local\\Vivaldi\\User Data\\Default\\").setValue(this.plugin.settings.notesPath).onChange((value) => {
        this.plugin.settings.notesPath = value;
        this.plugin.saveData(this.plugin.settings);
      })
    );
    new import_obsidian.Setting(containerEl).setName("Vault Location").setDesc("Search for the location where your vault is stored").addText(
      (text) => text.setPlaceholder("/").setValue(this.plugin.settings.vaultLocation).onChange((value) => {
        this.plugin.settings.vaultLocation = value;
        this.plugin.saveData(this.plugin.settings);
      })
      // .addSearch((search) => {
      //   search.setPlaceholder('Search for vault location').setDisabled(true);
      // })
    );
    new import_obsidian.Setting(containerEl).setName("Template for new notes").setDesc("The templates of how the note will be created").addTextArea(
      (text) => text.setPlaceholder("---\nguid: {{VIVALDI_GUID}}\nurl: {{URL}}\ndate_created:{{DATE_CREATED}}\n---\n{{CONTENT}}\n---\n{{IMAGES}}\n\n").setValue(this.plugin.settings.notesTemplate).onChange((value) => {
        this.plugin.settings.notesTemplate = value;
        this.plugin.saveData(this.plugin.settings);
      })
    );
    new import_obsidian.Setting(containerEl).setName("Interval for checking new notes").setDesc("The interval in milliseconds for checking new notes").addSlider(
      (number) => number.setDynamicTooltip().setLimits(5e3, 6e5, 5e3).setValue(this.plugin.settings.interval).onChange((value) => {
        this.plugin.settings.interval = value;
        this.plugin.saveData(this.plugin.settings);
      })
    );
  }
};

// view.ts
var import_obsidian2 = require("obsidian");

// utils.ts
function getFirstLineWithoutHash(str) {
  const regex = /^(?:#|\r|\n)*[ ]*.*?([^\n]{0,40})/gms;
  if (str == "" || str == null) {
    return "";
  }
  const match = regex.exec(str);
  if (match) {
    let firstLine = match[1].replace(/[\\\/<>:|?"-]/g, "");
    return firstLine.replace(/[.\s]+$/, "");
  }
  return "";
}

// view.ts
var fs = __toESM(require("fs"));

// node_modules/fuse.js/dist/fuse.mjs
function isArray(value) {
  return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
}
var INFINITY = 1 / 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  let result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return typeof value === "number";
}
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
}
function isObject(value) {
  return typeof value === "object";
}
function isObjectLike(value) {
  return isObject(value) && value !== null;
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isBlank(value) {
  return !value.trim().length;
}
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
var INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
var LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
var PATTERN_LENGTH_TOO_LARGE = (max) => `Pattern length exceeds max of ${max}.`;
var MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;
var INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
var hasOwn = Object.prototype.hasOwnProperty;
var KeyStore = class {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys.forEach((key) => {
      let obj = createKey(key);
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
};
function createKey(key) {
  let path = null;
  let id = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString(key) || isArray(key)) {
    src = key;
    path = createKeyPath(key);
    id = createKeyId(key);
  } else {
    if (!hasOwn.call(key, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name = key.name;
    src = name;
    if (hasOwn.call(key, "weight")) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path = createKeyPath(name);
    id = createKeyId(name);
    getFn = key.getFn;
  }
  return { path, id, weight, src, getFn };
}
function createKeyPath(key) {
  return isArray(key) ? key : key.split(".");
}
function createKeyId(key) {
  return isArray(key) ? key.join(".") : key;
}
function get(obj, path) {
  let list = [];
  let arr = false;
  const deepGet = (obj2, path2, index) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path2[index]) {
      list.push(obj2);
    } else {
      let key = path2[index];
      const value = obj2[key];
      if (!isDefined(value)) {
        return;
      }
      if (index === path2.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
        list.push(toString(value));
      } else if (isArray(value)) {
        arr = true;
        for (let i = 0, len = value.length; i < len; i += 1) {
          deepGet(value[i], path2, index + 1);
        }
      } else if (path2.length) {
        deepGet(value, path2, index + 1);
      }
    }
  };
  deepGet(obj, isString(path) ? path.split(".") : path, 0);
  return arr ? list : list[0];
}
var MatchOptions = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: false,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: false,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
};
var BasicOptions = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: false,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: false,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: true,
  // Default sort function: sort by ascending score, ascending index
  sortFn: (a, b) => a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1
};
var FuzzyOptions = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
};
var AdvancedOptions = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: false,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: get,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: false,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: false,
  // The weight to determine how much field length norm effects scoring.
  fieldNormWeight: 1
};
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
var SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache = /* @__PURE__ */ new Map();
  const m = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache.has(numTokens)) {
        return cache.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n = parseFloat(Math.round(norm2 * m) / m);
      cache.set(numTokens, n);
      return n;
    },
    clear() {
      cache.clear();
    }
  };
}
var FuseIndex = class {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }
    this.norm.clear();
  }
  // Adds a doc to the end of the index
  add(doc) {
    const idx = this.size();
    if (isString(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  // Removes the doc at the specified index of the index
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i = idx, len = this.size(); i < len; i += 1) {
      this.records[i].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return;
    }
    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };
    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key, keyIndex) => {
      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
      if (!isDefined(value)) {
        return;
      }
      if (isArray(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];
        while (stack.length) {
          const { nestedArrIndex, value: value2 } = stack.pop();
          if (!isDefined(value2)) {
            continue;
          }
          if (isString(value2) && !isBlank(value2)) {
            let subRecord = {
              v: value2,
              i: nestedArrIndex,
              n: this.norm.get(value2)
            };
            subRecords.push(subRecord);
          } else if (isArray(value2)) {
            value2.forEach((item, k) => {
              stack.push({
                nestedArrIndex: k,
                value: item
              });
            });
          } else
            ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
};
function createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys, records } = data;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start = -1;
  let end = -1;
  let i = 0;
  for (let len = matchmask.length; i < len; i += 1) {
    let match = matchmask[i];
    if (match && start === -1) {
      start = i;
    } else if (!match && start !== -1) {
      end = i - 1;
      if (end - start + 1 >= minMatchCharLength) {
        indices.push([start, end]);
      }
      start = -1;
    }
  }
  if (matchmask[i - 1] && i - start >= minMatchCharLength) {
    indices.push([start, i - 1]);
  }
  return indices;
}
var MAX_BITS = 32;
function search(text, pattern, patternAlphabet, {
  location = Config.location,
  distance = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text.length;
  const expectedLocation = Math.max(0, Math.min(location, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index;
  while ((index = text.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index,
      expectedLocation,
      distance,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index + patternLen;
    if (computeMatches) {
      let i = 0;
      while (i < patternLen) {
        matchMask[index + i] = 1;
        i += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i = 0; i < patternLen; i += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i) - 1;
    for (let j = finish; j >= start; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
      if (i) {
        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
      }
      if (bitArr[j] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask = {};
  for (let i = 0, len = pattern.length; i < len; i += 1) {
    const char = pattern.charAt(i);
    mask[char] = (mask[char] || 0) | 1 << len - i - 1;
  }
  return mask;
}
var BitapSearch = class {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;
      while (i < end) {
        addChunk(this.pattern.substr(i, MAX_BITS), i);
        i += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text = text.toLowerCase();
    }
    if (this.pattern === text) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text.length - 1]];
      }
      return result2;
    }
    const {
      location,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text, pattern, alphabet, {
        location: location + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
};
var BaseMatch = class {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
};
function getMatch(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null;
}
var ExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text) {
    const isMatch = text === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InverseExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text) {
    const index = text.indexOf(this.pattern);
    const isMatch = index === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
var PrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text) {
    const isMatch = text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InversePrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text) {
    const isMatch = !text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
var SuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text) {
    const isMatch = text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text.length - this.pattern.length, text.length - 1]
    };
  }
};
var InverseSuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text) {
    const isMatch = !text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
var FuzzyMatch = class extends BaseMatch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text) {
    return this._bitapSearch.searchIn(text);
  }
};
var IncludeMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text) {
    let location = 0;
    let index;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index = text.indexOf(this.pattern, location)) > -1) {
      location = index + patternLen;
      indices.push([index, location - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
};
var searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
var searchersLen = searchers.length;
var SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
var OR_TOKEN = "|";
function parseQuery(pattern, options = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
    let results = [];
    for (let i = 0, len = query.length; i < len; i += 1) {
      const queryItem = query[i];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          break;
        }
      }
    }
    return results;
  });
}
var MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
var ExtendedSearch = class {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location,
      threshold,
      distance
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_, options) {
    return options.useExtendedSearch;
  }
  searchIn(text) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text = isCaseSensitive ? text : text.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i = 0, qLen = query.length; i < qLen; i += 1) {
      const searchers2 = query[i];
      allIndices.length = 0;
      numMatches = 0;
      for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
        const searcher = searchers2[j];
        const { isMatch, indices, score } = searcher.search(text);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
};
var registeredSearchers = [];
function register(...args) {
  registeredSearchers.push(...args);
}
function createSearcher(pattern, options) {
  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
    let searcherClass = registeredSearchers[i];
    if (searcherClass.condition(pattern, options)) {
      return new searcherClass(pattern, options);
    }
  }
  return new BitapSearch(pattern, options);
}
var LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
var KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
var isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
var isPath = (query) => !!query[KeyType.PATH];
var isLeaf = (query) => !isArray(query) && isObject(query) && !isExpression(query);
var convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
});
function parse(query, options, { auto = true } = {}) {
  const next = (query2) => {
    let keys = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
      return next(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key = isQueryPath ? query2[KeyType.PATH] : keys[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto) {
        obj.searcher = createSearcher(pattern, options);
      }
      return obj;
    }
    let node = {
      children: [],
      operator: keys[0]
    };
    keys.forEach((key) => {
      const value = query2[key];
      if (isArray(value)) {
        value.forEach((item) => {
          node.children.push(next(item));
        });
      }
    });
    return node;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next(query);
}
function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key, norm: norm2, score }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(
        score === 0 && weight ? Number.EPSILON : score,
        (weight || 1) * (ignoreFieldNorm ? 1 : norm2)
      );
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data) {
  const matches = result.matches;
  data.matches = [];
  if (!isDefined(matches)) {
    return;
  }
  matches.forEach((match) => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return;
    }
    const { indices, value } = match;
    let obj = {
      indices,
      value
    };
    if (match.key) {
      obj.key = match.key.src;
    }
    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }
    data.matches.push(obj);
  });
}
function transformScore(result, data) {
  data.score = result.score;
}
function format(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches)
    transformers.push(transformMatches);
  if (includeScore)
    transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }
    return data;
  });
}
var Fuse = class {
  constructor(docs, options = {}, index) {
    this.options = { ...Config, ...options };
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index);
  }
  setCollection(docs, index) {
    this._docs = docs;
    if (index && !(index instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc) {
    if (!isDefined(doc)) {
      return;
    }
    this._docs.push(doc);
    this._myIndex.add(doc);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i = 0, len = this._docs.length; i < len; i += 1) {
      const doc = this._docs[i];
      if (predicate(doc, i)) {
        this.removeAt(i);
        i -= 1;
        len -= 1;
        results.push(doc);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text, i: idx, n: norm2 }) => {
      if (!isDefined(text)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text);
      if (isMatch) {
        results.push({
          item: text,
          idx,
          matches: [{ score, value: text, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse(query, this.options);
    const evaluate = (node, item, idx) => {
      if (!node.children) {
        const { keyId, searcher } = node;
        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });
        if (matches && matches.length) {
          return [
            {
              idx,
              item,
              matches
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i = 0, len = node.children.length; i < len; i += 1) {
        const child = node.children[i];
        const result = evaluate(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (isDefined(item)) {
        let expResults = evaluate(expression, item, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined(item)) {
        return;
      }
      let matches = [];
      keys.forEach((key, keyIndex) => {
        matches.push(
          ...this._findMatches({
            key,
            value: item[keyIndex],
            searcher
          })
        );
      });
      if (matches.length) {
        results.push({
          idx,
          item,
          matches
        });
      }
    });
    return results;
  }
  _findMatches({ key, value, searcher }) {
    if (!isDefined(value)) {
      return [];
    }
    let matches = [];
    if (isArray(value)) {
      value.forEach(({ v: text, i: idx, n: norm2 }) => {
        if (!isDefined(text)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text);
        if (isMatch) {
          matches.push({
            score,
            key,
            value: text,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text, n: norm2 } = value;
      const { isMatch, score, indices } = searcher.searchIn(text);
      if (isMatch) {
        matches.push({ score, key, value: text, norm: norm2, indices });
      }
    }
    return matches;
  }
};
Fuse.version = "7.0.0";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse;
}
{
  register(ExtendedSearch);
}

// view.ts
var import_lodash = __toESM(require_lodash());
var VIEW_TYPE = "vivaldi-notes-view";
var VIVALDI_NOTES_PATH_WIN = "C:\\Users\\USUARIO\\AppData\\Local\\Vivaldi\\User Data\\Default\\";
var checkCircle = `<svg xmlns="http://www.w3.org/2000/svg" class="check-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-check-circle"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>`;
var VivaldiNotesView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    // root: Root | null = null;
    // settings:
    this.previousChecksum = "";
    this.fuse = null;
    this.notesList = [];
    this.options = {
      includeScore: true,
      keys: [{ name: "title", weight: 0.6 }, { name: "content", weight: 0.1 }, { name: "id", weight: 0.3 }]
    };
    this.renderedList = null;
    this.intervalId = null;
    this.plugin = plugin;
  }
  // notes = getNotesJSON()
  getViewType() {
    return VIEW_TYPE;
  }
  getDisplayText() {
    return "Vivaldi Notes Viewer";
  }
  getIcon() {
    return "calendar-clock";
  }
  async onOpen() {
    console.log("Opened Vivaldi Notes Viewer");
    const container = this.containerEl.children[1];
    container.empty();
    container.createEl("h4", { text: "Vivaldi Notes" });
    const { notes, checksum: prChecksum } = await this.getNotesJSON(VIVALDI_NOTES_PATH_WIN);
    this.previousChecksum = prChecksum;
    this.appNotes = notes.map((note) => {
      let title = getFirstLineWithoutHash(note.content);
      return { ...note, title };
    });
    this.fuse = new Fuse(this.appNotes, this.options);
    this.notesList = this.appNotes;
    const searchBar = container.createEl("input", { cls: "search-bar", attr: { type: "search", placeholder: "Search...", enterKeyhint: "search" } });
    this.renderedList = container.createEl("ul", { cls: "vivaldi-notes-list" });
    searchBar.addEventListener("input", (0, import_lodash.default)((e) => {
      var _a, _b, _c, _d, _e, _f, _g;
      let value = (_a = e.target) == null ? void 0 : _a.value;
      if (((_b = e.target) == null ? void 0 : _b.value) != null && ((_c = e.target) == null ? void 0 : _c.value) != void 0 && ((_d = e.target) == null ? void 0 : _d.value) != "") {
        let resultado = this.fuse.search(e.target.value);
        this.notesList = resultado.map((note) => note.item);
        while ((_e = this.renderedList) == null ? void 0 : _e.firstChild) {
          (_f = this.renderedList) == null ? void 0 : _f.removeChild(this.renderedList.firstChild);
        }
        if (this.notesList != null) {
          this.renderNotes(this.notesList);
        }
      } else if (((_g = e.target) == null ? void 0 : _g.value) == "") {
        this.renderNotes(this.appNotes);
      }
    }, 120));
    this.renderNotes(this.appNotes);
    this.intervalId = this.registerInterval(1);
  }
  onviewwillunload() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
    }
  }
  registerInterval(id) {
    const intervalTime = this.plugin.settings.interval;
    return window.setInterval(async () => {
      var _a, _b, _c;
      const currentChecksum = await this.getNotesChecksum(VIVALDI_NOTES_PATH_WIN);
      console.log(currentChecksum);
      if (currentChecksum !== this.previousChecksum) {
        const { notes: newNotesList } = await this.getNotesJSON(VIVALDI_NOTES_PATH_WIN);
        this.appNotes = newNotesList.map((note) => {
          let title = getFirstLineWithoutHash(note.content);
          return { ...note, title };
        });
        this.fuse = new Fuse(this.appNotes, this.options);
        let notesList = this.appNotes;
        while ((_a = this.renderedList) == null ? void 0 : _a.firstChild) {
          (_c = this.renderedList) == null ? void 0 : _c.removeChild((_b = this.renderedList) == null ? void 0 : _b.firstChild);
        }
        await this.renderNotes(notesList);
        this.previousChecksum = currentChecksum;
      }
    }, intervalTime);
  }
  async renderNotes(list) {
    await list.filter((note) => note.type === "note" && note.content).forEach((note) => {
      var _a, _b;
      (_a = this.renderedList) == null ? void 0 : _a.createEl("li", { text: note.title.length == 40 ? note.title + "..." : note.title, cls: "vivaldi-notes-list-item", attr: { id: note.id } }).onClickEvent(async (event) => {
        if (!this.verifyCreatedNotes(note.title)) {
          event.target.innerHTML += checkCircle;
          this.createNewNote(note.title, note);
        } else {
          this.app.workspace.openLinkText(note.title, "", true);
        }
      });
      if (this.verifyCreatedNotes(note.title)) {
        ((_b = this.renderedList) == null ? void 0 : _b.lastElementChild).innerHTML += checkCircle;
      }
    });
  }
  async getNotesJSON(path) {
    let stringpath = path + "Notes";
    const fileContents = await fs.readFileSync(stringpath, "utf8");
    let dato = JSON.parse(fileContents);
    return { notes: dato.children, checksum: dato.checksum };
  }
  async getNotesChecksum(path) {
    let stringpath = path + "Notes";
    const fileContents = await fs.readFileSync(stringpath);
    const checksum = fileContents.slice(19, 51).toString();
    return checksum;
  }
  async createNewNote(title, note) {
    let content = this.plugin.settings.notesTemplate.replace("{{VIVALDI_GUID}}", note.guid ? note.guid : "").replace("{{VIVALDI_ID}}", note.id ? note.id.toString() : "").replace("{{URL}}", note.url ? note.url : "").replace("{{DATE_CREATED}}", note.date_added ? new Date((note.date_added - 116444736e8) / 1e3).toISOString() : "").replace("{{CONTENT}}", note.content ? note.content : "");
    if (note.children.length > 0) {
      let imageArray = note.children.filter((child) => child.type === "attachment").map((child) => `
<img src="${this.plugin.settings.notesPath}\\SyncedFiles\\${child.content}" width="100%" height="auto"/>
`);
      content = content.replace("{{IMAGES}}", imageArray.toString());
    } else {
      content = content.replace("{{IMAGES}}", "");
    }
    let carpeta = this.plugin.settings.vaultLocation;
    carpeta += this.plugin.settings.vaultLocation == "/" ? "" : "/";
    const stringpath = carpeta + title + ".md";
    const newNote = await this.app.vault.create(stringpath, content);
    await this.app.workspace.openLinkText(newNote.path, "", true);
    return newNote;
  }
  async getNoteFile(notePath2) {
    const file = this.app.vault.getAbstractFileByPath(notePath2);
    if (!file || !(file instanceof import_obsidian2.TFile)) {
      throw new Error(`File not found: ${notePath2}`);
    }
    return file;
  }
  async getNotesMetadata(notePathORContentString, type) {
    if (type == "file" && notePathORContentString instanceof import_obsidian2.TFile) {
      const file2 = notePathORContentString;
    } else if (type == "string" && typeof notePathORContentString == "string") {
      const file2 = this.app.vault.read();
    }
    const file = await typeof notePath == "string" ? notePath : this.app.vault.read(await this.getNoteFile(notePath));
    const frontmatterRegex = /^---\n([\s\S]*?)\n---\n/;
    const match = file.match(frontmatterRegex);
    if (!match) {
      return false;
    }
    const frontmatter = (0, import_obsidian2.parseYaml)(match[1]);
    return frontmatter;
  }
  verifyCreatedNotes(title) {
    let carpeta = this.plugin.settings.vaultLocation;
    carpeta += this.plugin.settings.vaultLocation == "/" ? "" : "/";
    const stringpath = title + ".md";
    const noteExists = this.app.vault.getAbstractFileByPath(stringpath) !== null;
    return noteExists;
  }
  async onClose() {
    console.log("Closed Vivaldi Notes Viewer, stopped interval");
    if (this.intervalId) {
      clearInterval(this.intervalId);
    }
  }
};

// main.ts
var VivaldiNotesPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new VivaldiNotesSettingtTab(this.app, this));
    this.registerView(VIEW_TYPE, (leaf) => new VivaldiNotesView(leaf, this));
    this.addCommand({
      id: "show-vivaldi-notes",
      name: "Show Vivaldi Notes",
      callback: () => {
        this.app.workspace.getRightLeaf(false).setViewState({
          type: VIEW_TYPE,
          state: "sa",
          pinned: true
        });
      }
    });
    this.registerInterval(
      window.setInterval(() => console.log("setInterval"), 5 * 60 * 1e3)
    );
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async activateView() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE);
    await this.app.workspace.getRightLeaf(false).setViewState({
      type: VIEW_TYPE,
      active: true
    });
    this.app.workspace.revealLeaf(
      this.app.workspace.getLeavesOfType(VIEW_TYPE)[0]
    );
  }
  // async createNewNote(title: string, content: string, url?: string)  {
  //   const newNote = await this.app.vault.create(this.settings.vaultLocation+title, content);
  //   // await this.app.vault.modify(newNote, content);
  //   return newNote;
  // }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL2xvZGFzaC5kZWJvdW5jZS9pbmRleC5qcyIsICJtYWluLnRzIiwgInNldHRpbmcudHMiLCAidmlldy50cyIsICJ1dGlscy50cyIsICJub2RlX21vZHVsZXMvZnVzZS5qcy9kaXN0L2Z1c2UubWpzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG52YXIgbm93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAqIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICpcbiAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICogICAnbGVhZGluZyc6IHRydWUsXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgIHJlc3VsdCA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmcgPyBuYXRpdmVNaW4ocmVzdWx0LCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2U7XG4iLCAiaW1wb3J0IHtcbiAgUGx1Z2luLFxufSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IERFRkFVTFRfU0VUVElOR1MsIFZpdmFsZGlOb3Rlc1NldHRpbmcsIFZpdmFsZGlOb3Rlc1NldHRpbmd0VGFiIH0gZnJvbSBcInNldHRpbmdcIjtcbmltcG9ydCB7IFZJRVdfVFlQRSwgVml2YWxkaU5vdGVzVmlldyB9IGZyb20gXCIuL3ZpZXdcIjtcblxuLy8gUmVtZW1iZXIgdG8gcmVuYW1lIHRoZXNlIGNsYXNzZXMgYW5kIGludGVyZmFjZXMhXG5cbi8vIGludGVyZmFjZSBNeVBsdWdpblNldHRpbmdzIHtcbi8vICAgbXlTZXR0aW5nOiBzdHJpbmc7XG4vLyB9XG5cbi8vIGNvbnN0IERFRkFVTFRfU0VUVElOR1M6IE15UGx1Z2luU2V0dGluZ3MgPSB7XG4vLyAgIG15U2V0dGluZzogXCJkZWZhdWx0XCIsXG4vLyB9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaXZhbGRpTm90ZXNQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuICBzZXR0aW5nczogVml2YWxkaU5vdGVzU2V0dGluZztcblxuICBhc3luYyBvbmxvYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcbiAgICBcbiAgICB0aGlzLmFkZFNldHRpbmdUYWIobmV3IFZpdmFsZGlOb3Rlc1NldHRpbmd0VGFiKHRoaXMuYXBwLCB0aGlzKSk7XG5cbiAgICB0aGlzLnJlZ2lzdGVyVmlldyhWSUVXX1RZUEUsIGxlYWYgPT4gbmV3IFZpdmFsZGlOb3Rlc1ZpZXcobGVhZiwgdGhpcykpO1xuXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiBcInNob3ctdml2YWxkaS1ub3Rlc1wiLFxuICAgICAgbmFtZTogXCJTaG93IFZpdmFsZGkgTm90ZXNcIixcbiAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS5nZXRSaWdodExlYWYoZmFsc2UpLnNldFZpZXdTdGF0ZSh7XG4gICAgICAgICAgdHlwZTogVklFV19UWVBFLFxuICAgICAgICAgIHN0YXRlOiBcInNhXCIsXG4gICAgICAgICAgcGlubmVkOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvLyBXaGVuIHJlZ2lzdGVyaW5nIGludGVydmFscywgdGhpcyBmdW5jdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgY2xlYXIgdGhlIGludGVydmFsIHdoZW4gdGhlIHBsdWdpbiBpcyBkaXNhYmxlZC5cbiAgICB0aGlzLnJlZ2lzdGVySW50ZXJ2YWwoXG4gICAgICB3aW5kb3cuc2V0SW50ZXJ2YWwoKCkgPT4gY29uc29sZS5sb2coXCJzZXRJbnRlcnZhbFwiKSwgNSAqIDYwICogMTAwMClcbiAgICApO1xuICB9XG5cbiAgb251bmxvYWQoKSB7XG4gICAgXG4gICAgLy8gV2hlbiB1bmxvYWRpbmcsIHdlIG5lZWQgdG8gbWFudWFsbHkgcmVtb3ZlIHRoZSB2aWV3IGZyb20gdGhlIHdvcmtzcGFjZS5cbiAgICB0aGlzLmFwcC53b3Jrc3BhY2UuZGV0YWNoTGVhdmVzT2ZUeXBlKFZJRVdfVFlQRSk7XG4gIH1cblxuICBhc3luYyBsb2FkU2V0dGluZ3MoKSB7XG4gICAgdGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MsIGF3YWl0IHRoaXMubG9hZERhdGEoKSk7XG4gICAgXG4gIH1cblxuICBhc3luYyBzYXZlU2V0dGluZ3MoKSB7XG4gICAgYXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcbiAgfVxuICBhc3luYyBhY3RpdmF0ZVZpZXcoKSB7XG4gICAgdGhpcy5hcHAud29ya3NwYWNlLmRldGFjaExlYXZlc09mVHlwZShWSUVXX1RZUEUpO1xuXG4gICAgYXdhaXQgdGhpcy5hcHAud29ya3NwYWNlLmdldFJpZ2h0TGVhZihmYWxzZSkuc2V0Vmlld1N0YXRlKHtcbiAgICAgIHR5cGU6IFZJRVdfVFlQRSxcbiAgICAgIGFjdGl2ZTogdHJ1ZSxcbiAgICB9KVxuICAgIFxuICAgIHRoaXMuYXBwLndvcmtzcGFjZS5yZXZlYWxMZWFmKFxuICAgICAgdGhpcy5hcHAud29ya3NwYWNlLmdldExlYXZlc09mVHlwZShWSUVXX1RZUEUpWzBdXG4gICAgKTtcbiAgfVxuXG4gIC8vIGFzeW5jIGNyZWF0ZU5ld05vdGUodGl0bGU6IHN0cmluZywgY29udGVudDogc3RyaW5nLCB1cmw/OiBzdHJpbmcpICB7XG4gIC8vICAgY29uc3QgbmV3Tm90ZSA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZSh0aGlzLnNldHRpbmdzLnZhdWx0TG9jYXRpb24rdGl0bGUsIGNvbnRlbnQpO1xuICAvLyAgIC8vIGF3YWl0IHRoaXMuYXBwLnZhdWx0Lm1vZGlmeShuZXdOb3RlLCBjb250ZW50KTtcbiAgLy8gICByZXR1cm4gbmV3Tm90ZTtcbiAgLy8gfVxufVxuXG4vLyBjbGFzcyBTYW1wbGVNb2RhbCBleHRlbmRzIE1vZGFsIHtcbi8vICAgY29uc3RydWN0b3IoYXBwOiBBcHApIHtcbi8vICAgICBzdXBlcihhcHApO1xuLy8gICB9XG5cbi8vICAgb25PcGVuKCkge1xuLy8gICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xuLy8gICAgIGNvbnRlbnRFbC5zZXRUZXh0KFwiV29haCFcIik7XG4vLyAgIH1cblxuLy8gICBvbkNsb3NlKCkge1xuLy8gICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xuLy8gICAgIGNvbnRlbnRFbC5lbXB0eSgpO1xuLy8gICB9XG4vLyB9XG5cbi8vIGNsYXNzIE15VmlldyBleHRlbmRzIE1hcmtkb3duVmlldyB7XG4vLyAgIGdldFZpZXdUeXBlKCk6IHN0cmluZyB7XG4vLyAgICAgcmV0dXJuIFwibXktcGx1Z2luXCI7XG4vLyAgIH1cbi8vIH1cblxuLy8gY2xhc3MgU2FtcGxlU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuLy8gICBwbHVnaW46IE15UGx1Z2luO1xuXG4vLyAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IE15UGx1Z2luKSB7XG4vLyAgICAgc3VwZXIoYXBwLCBwbHVnaW4pO1xuLy8gICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuLy8gICB9XG5cbi8vICAgZGlzcGxheSgpOiB2b2lkIHtcbi8vICAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuXG4vLyAgICAgY29udGFpbmVyRWwuZW1wdHkoKTtcblxuLy8gICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuLy8gICAgICAgLnNldE5hbWUoXCJTZXR0aW5nICMxXCIpXG4vLyAgICAgICAuc2V0RGVzYyhcIkl0J3MgYSBzZWNyZXRcIilcbi8vICAgICAgIC5hZGRUZXh0KHRleHQgPT5cbi8vICAgICAgICAgdGV4dFxuLy8gICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihcIkVudGVyIHlvdXIgc2VjcmV0XCIpXG4vLyAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLm15U2V0dGluZylcbi8vICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgdmFsdWUgPT4ge1xuLy8gICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MubXlTZXR0aW5nID0gdmFsdWU7XG4vLyAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbi8vICAgICAgICAgICB9KVxuLy8gICAgICAgKTtcbi8vICAgfVxuLy8gfVxuIiwgImltcG9ydCBWaXZhbGRpTm90ZXNQbHVnaW4gZnJvbSAnbWFpbic7XG5pbXBvcnQgeyBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nLCBBcHAgfSBmcm9tICdvYnNpZGlhbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVml2YWxkaU5vdGVzU2V0dGluZyB7XG4gIG5vdGVzUGF0aDogc3RyaW5nO1xuICB2YXVsdExvY2F0aW9uOiBzdHJpbmc7XG4gIG5vdGVzVGVtcGxhdGU6IHN0cmluZztcbiAgaW50ZXJ2YWw6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfU0VUVElOR1M6IFBhcnRpYWw8Vml2YWxkaU5vdGVzU2V0dGluZz4gPSB7XG4gIG5vdGVzUGF0aDogJ0M6XFxcXFVzZXJzXFxcXFVTVUFSSU9cXFxcQXBwRGF0YVxcXFxMb2NhbFxcXFxWaXZhbGRpXFxcXFVzZXIgRGF0YVxcXFxEZWZhdWx0XFxcXCcsXG4gIHZhdWx0TG9jYXRpb246ICcvJyxcbiAgaW50ZXJ2YWw6IDQ1MDAwLFxuICBub3Rlc1RlbXBsYXRlOiBcIi0tLVxcbmd1aWQ6IHt7VklWQUxESV9HVUlEfX1cXG51cmw6IHt7VVJMfX1cXG5kYXRlX2NyZWF0ZWQ6IHt7REFURV9DUkVBVEVEfX1cXG4tLS1cXG57e0NPTlRFTlR9fVxcbi0tLVxcbnt7SU1BR0VTfX1cXG5cXG5cIlxufTtcblxuZXhwb3J0IGNsYXNzIFZpdmFsZGlOb3Rlc1NldHRpbmd0VGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XG4gIHBsdWdpbjogVml2YWxkaU5vdGVzUGx1Z2luO1xuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IFZpdmFsZGlOb3Rlc1BsdWdpbikge1xuICAgIHN1cGVyKGFwcCwgcGx1Z2luKTtcbiAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgICBcbiAgfVxuICBcbiAgZGlzcGxheSgpOiB2b2lkIHtcbiAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuXG4gICAgY29udGFpbmVyRWwuZW1wdHkoKTtcbiAgICBcbiAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdWaXZhbGRpIE5vdGVzIFNldHRpbmdzJyB9KTtcblxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgLnNldE5hbWUoJ1ZpdmFsZGkgbm90ZXMgcGF0aCBOb3RlcyBQYXRoJylcbiAgICAgIC5zZXREZXNjKCdUaGUgcGF0aCB3aGVyZSB2aXZhbGRpIHN0b3JlIHlvdXIgbm90ZXMuIFlvdSBjYW4gZmluZCBpdCBpbiB2aXZhbGRpOi8vYWJvdXQvIGluIHRoZSBVc2VyIFByb2ZpbGUgUGF0aCcpXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT5cbiAgICAgICAgdGV4dFxuICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignQzpcXFxcVXNlcnNcXFxcVVNVQVJJT1xcXFxBcHBEYXRhXFxcXExvY2FsXFxcXFZpdmFsZGlcXFxcVXNlciBEYXRhXFxcXERlZmF1bHRcXFxcJylcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Mubm90ZXNQYXRoKVxuICAgICAgICAgIC5vbkNoYW5nZSgodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLm5vdGVzUGF0aCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2F2ZURhdGEodGhpcy5wbHVnaW4uc2V0dGluZ3MpO1xuICAgICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZSgnVmF1bHQgTG9jYXRpb24nKVxuICAgICAgLnNldERlc2MoJ1NlYXJjaCBmb3IgdGhlIGxvY2F0aW9uIHdoZXJlIHlvdXIgdmF1bHQgaXMgc3RvcmVkJylcbiAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PlxuICAgICAgICB0ZXh0XG4gICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCcvJylcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MudmF1bHRMb2NhdGlvbilcbiAgICAgICAgICAub25DaGFuZ2UoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy52YXVsdExvY2F0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlRGF0YSh0aGlzLnBsdWdpbi5zZXR0aW5ncyk7XG4gICAgICAgICAgfSlcbiAgICAgIC8vIC5hZGRTZWFyY2goKHNlYXJjaCkgPT4ge1xuICAgICAgLy8gICBzZWFyY2guc2V0UGxhY2Vob2xkZXIoJ1NlYXJjaCBmb3IgdmF1bHQgbG9jYXRpb24nKS5zZXREaXNhYmxlZCh0cnVlKTtcbiAgICAgIC8vIH0pXG4gICAgICApO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZSgnVGVtcGxhdGUgZm9yIG5ldyBub3RlcycpXG4gICAgICAuc2V0RGVzYygnVGhlIHRlbXBsYXRlcyBvZiBob3cgdGhlIG5vdGUgd2lsbCBiZSBjcmVhdGVkJylcbiAgICAgIC5hZGRUZXh0QXJlYSgodGV4dCkgPT5cbiAgICAgICAgdGV4dFxuICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignLS0tXFxuZ3VpZDoge3tWSVZBTERJX0dVSUR9fVxcbnVybDoge3tVUkx9fVxcbmRhdGVfY3JlYXRlZDp7e0RBVEVfQ1JFQVRFRH19XFxuLS0tXFxue3tDT05URU5UfX1cXG4tLS1cXG57e0lNQUdFU319XFxuXFxuJylcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Mubm90ZXNUZW1wbGF0ZSlcbiAgICAgICAgICAub25DaGFuZ2UoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5ub3Rlc1RlbXBsYXRlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlRGF0YSh0aGlzLnBsdWdpbi5zZXR0aW5ncyk7XG4gICAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgLnNldE5hbWUoJ0ludGVydmFsIGZvciBjaGVja2luZyBuZXcgbm90ZXMnKVxuICAgICAgLnNldERlc2MoJ1RoZSBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHMgZm9yIGNoZWNraW5nIG5ldyBub3RlcycpXG4gICAgICAuYWRkU2xpZGVyKChudW1iZXIpID0+XG4gICAgICAgIG51bWJlclxuICAgICAgICAgIC5zZXREeW5hbWljVG9vbHRpcCgpXG4gICAgICAgICAgLnNldExpbWl0cyg1MDAwLCA2MDAwMDAsIDUwMDApXG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmludGVydmFsKVxuICAgICAgICAgIC5vbkNoYW5nZSgodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmludGVydmFsPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVEYXRhKHRoaXMucGx1Z2luLnNldHRpbmdzKTtcbiAgICAgICAgICB9KVxuICAgICAgKTtcbiAgfVxufSIsICJpbXBvcnQgeyBJdGVtVmlldywgVEZpbGUsIFdvcmtzcGFjZUxlYWYsIHBhcnNlWWFtbCwgc2V0SWNvbiwgIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBnZXRGaXJzdExpbmVXaXRob3V0SGFzaCB9IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgKiBhcyBmcyBmcm9tIFwiZnNcIjtcbmltcG9ydCBWaXZhbGRpTm90ZXNQbHVnaW4gZnJvbSBcIi4vbWFpblwiO1xuLy8gaW1wb3J0IHtSb290fSBmcm9tIFwicmVhY3QtZG9tL2NsaWVudFwiO1xuaW1wb3J0IEZ1c2UgZnJvbSBcImZ1c2UuanNcIjtcbmltcG9ydCBkZWJvdW5jZSBmcm9tICdsb2Rhc2guZGVib3VuY2UnO1xuXG5leHBvcnQgY29uc3QgVklFV19UWVBFID0gXCJ2aXZhbGRpLW5vdGVzLXZpZXdcIjtcblxuaW50ZXJmYWNlIE5vdGUge1xuICBkYXRlX2FkZGVkOiBudW1iZXJcbiAgY29udGVudDogc3RyaW5nO1xuICBndWlkOiBzdHJpbmc7XG4gIGlkOiBudW1iZXI7XG4gIHR5cGU6IFwibm90ZVwiIHwgXCJmb2xkZXJcIiB8IFwiYXR0YWNobWVudFwiO1xuICB1cmw6IHN0cmluZztcbiAgY2hpbGRyZW46IE5vdGVbXTtcbiAgc3ViamVjdD86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIE5vdGVzIHtcbiAgY2hlY2tzdW06IHN0cmluZztcbiAgY2hpbGRyZW46IE5vdGVbXTtcbn1cblxuaW50ZXJmYWNlIEFwcE5vdGUgZXh0ZW5kcyBOb3RlIHtcbiAgdGl0bGU6IHN0cmluZztcbiAgaXNBbHJlYWR5Q3JlYXRlZD86IGJvb2xlYW47XG59XG5cbmNvbnN0IFZJVkFMRElfTk9URVNfUEFUSF9XSU4gPSBcIkM6XFxcXFVzZXJzXFxcXFVTVUFSSU9cXFxcQXBwRGF0YVxcXFxMb2NhbFxcXFxWaXZhbGRpXFxcXFVzZXIgRGF0YVxcXFxEZWZhdWx0XFxcXFwiO1xuY29uc3QgVklWQUxESV9OT1RFU19QQVRIX0xJTiA9IFwiL21udC9jL1VzZXJzL1VTVUFSSU8vQXBwRGF0YS9Mb2NhbC9WaXZhbGRpL1VzZXJcXCBEYXRhL0RlZmF1bHQvXCI7XG5cbmNvbnN0IGNoZWNrQ2lyY2xlID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiY2hlY2staWNvblwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBjbGFzcz1cImZlYXRoZXIgZmVhdGhlci1jaGVjay1jaXJjbGVcIj48cGF0aCBkPVwiTTIyIDExLjA4VjEyYTEwIDEwIDAgMSAxLTUuOTMtOS4xNFwiPjwvcGF0aD48cG9seWxpbmUgcG9pbnRzPVwiMjIgNCAxMiAxNC4wMSA5IDExLjAxXCI+PC9wb2x5bGluZT48L3N2Zz5gXG5cbmxldCBpbnRlcnZhbElkOiBOb2RlSlMuVGltZW91dCB8IG51bGw7XG5leHBvcnQgY2xhc3MgVml2YWxkaU5vdGVzVmlldyBleHRlbmRzIEl0ZW1WaWV3IHtcbiAgcGx1Z2luOiBWaXZhbGRpTm90ZXNQbHVnaW47XG4gIC8vIHJvb3Q6IFJvb3QgfCBudWxsID0gbnVsbDtcbiAgLy8gc2V0dGluZ3M6XG4gIHByZXZpb3VzQ2hlY2tzdW06IHN0cmluZyA9IFwiXCI7XG4gIGZ1c2U6IEZ1c2U8Tm90ZSwgRnVzZS5GdXNlT3B0aW9uczxOb3RlPj4gfCBudWxsID0gbnVsbDtcbiAgbm90ZXNMaXN0OiBOb3RlW10gPSBbXTtcbiAgYXBwTm90ZXM6ICBBcHBOb3RlW107XG4gIG9wdGlvbnMgPSB7XG4gICAgaW5jbHVkZVNjb3JlOiB0cnVlLFxuICAgIGtleXM6IFt7bmFtZTondGl0bGUnLCB3ZWlnaHQ6IDAuNn0se25hbWU6J2NvbnRlbnQnLCB3ZWlnaHQ6IDAuMX0sIHtuYW1lOidpZCcsIHdlaWdodDogMC4zfV1cbiAgfVxuICByZW5kZXJlZExpc3Q6SFRNTFVMaXN0RWxlbWVudCB8IG51bGwgPSBudWxsO1xuICBpbnRlcnZhbElkOiBudW1iZXIgfCBudWxsID0gbnVsbDtcblxuICBcbiAgY29uc3RydWN0b3IobGVhZjogV29ya3NwYWNlTGVhZiwgcGx1Z2luOiBWaXZhbGRpTm90ZXNQbHVnaW4pIHtcbiAgICBzdXBlcihsZWFmKTtcbiAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgfVxuXG4gIC8vIG5vdGVzID0gZ2V0Tm90ZXNKU09OKClcblxuICBnZXRWaWV3VHlwZSgpIHtcbiAgICByZXR1cm4gVklFV19UWVBFO1xuICB9XG4gIGdldERpc3BsYXlUZXh0KCkge1xuICAgIHJldHVybiBcIlZpdmFsZGkgTm90ZXMgVmlld2VyXCI7XG4gIH1cbiAgZ2V0SWNvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiBcImNhbGVuZGFyLWNsb2NrXCI7XG4gIH1cbiAgXG4gIFxuICBhc3luYyBvbk9wZW4oKSB7XG4gICAgY29uc29sZS5sb2coXCJPcGVuZWQgVml2YWxkaSBOb3RlcyBWaWV3ZXJcIilcbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lckVsLmNoaWxkcmVuWzFdO1xuICAgIGNvbnRhaW5lci5lbXB0eSgpO1xuICAgIGNvbnRhaW5lci5jcmVhdGVFbChcImg0XCIsIHsgdGV4dDogXCJWaXZhbGRpIE5vdGVzXCIgfSk7XG4gICAgY29uc3Qge25vdGVzLCBjaGVja3N1bTogcHJDaGVja3N1bX0gPSBhd2FpdCB0aGlzLmdldE5vdGVzSlNPTihWSVZBTERJX05PVEVTX1BBVEhfV0lOKVxuICAgIHRoaXMucHJldmlvdXNDaGVja3N1bSA9IHByQ2hlY2tzdW07XG5cblxuICAgIHRoaXMuYXBwTm90ZXMgPSBub3Rlcy5tYXAoKG5vdGUpID0+IHtcbiAgICAgIGxldCB0aXRsZSA9IGdldEZpcnN0TGluZVdpdGhvdXRIYXNoKG5vdGUuY29udGVudCk7XG4gICAgICByZXR1cm4geyAuLi5ub3RlLCB0aXRsZSB9OyAvLyBUaGlzIGNyZWF0ZXMgYSBuZXcgb2JqZWN0IHdpdGggYWxsIHByb3BlcnRpZXMgb2Ygbm90ZSBhbmQgdGhlIG5ldyB0aXRsZSBwcm9wZXJ0eVxuICAgIH0pO1xuXG4gICAgdGhpcy5mdXNlID0gbmV3IEZ1c2UodGhpcy5hcHBOb3RlcywgdGhpcy5vcHRpb25zKVxuXG4gICAgdGhpcy5ub3Rlc0xpc3QgPSB0aGlzLmFwcE5vdGVzXG5cbiAgICBjb25zdCBzZWFyY2hCYXIgPSBjb250YWluZXIuY3JlYXRlRWwoXCJpbnB1dFwiLCB7IGNsczpcInNlYXJjaC1iYXJcIiwgYXR0cjogeyB0eXBlOiBcInNlYXJjaFwiLCBwbGFjZWhvbGRlcjogXCJTZWFyY2guLi5cIiwgZW50ZXJLZXloaW50Olwic2VhcmNoXCIgfSB9KTtcbiAgICB0aGlzLnJlbmRlcmVkTGlzdCA9IGNvbnRhaW5lci5jcmVhdGVFbChcInVsXCIsIHsgY2xzOiBcInZpdmFsZGktbm90ZXMtbGlzdFwiIH0pO1xuXG4gICAgc2VhcmNoQmFyLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBkZWJvdW5jZSgoZSkgPT4ge1xuICAgICAgbGV0IHZhbHVlID0gZS50YXJnZXQ/LnZhbHVlIFxuICAgICAgaWYoZS50YXJnZXQ/LnZhbHVlICE9IG51bGwgJiYgZS50YXJnZXQ/LnZhbHVlICE9IHVuZGVmaW5lZCAmJiBlLnRhcmdldD8udmFsdWUgIT0gXCJcIikge1xuICAgICAgICBsZXQgcmVzdWx0YWRvID0gdGhpcy5mdXNlLnNlYXJjaChlLnRhcmdldC52YWx1ZSlcbiAgICAgICAgdGhpcy5ub3Rlc0xpc3QgPSByZXN1bHRhZG8ubWFwKChub3RlKSA9PiBub3RlLml0ZW0pXG5cbiAgICAgICAgd2hpbGUgKHRoaXMucmVuZGVyZWRMaXN0Py5maXJzdENoaWxkKSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJlZExpc3Q/LnJlbW92ZUNoaWxkKHRoaXMucmVuZGVyZWRMaXN0LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZih0aGlzLm5vdGVzTGlzdCAhPSBudWxsKSB7dGhpcy5yZW5kZXJOb3Rlcyh0aGlzLm5vdGVzTGlzdCl9XG5cbiAgICAgIH0gZWxzZSBpZiAoZS50YXJnZXQ/LnZhbHVlID09IFwiXCIpIHtcbiAgICAgICAgLy8gd2hpbGUgKHVsLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgLy8gICB1bC5yZW1vdmVDaGlsZCh1bC5maXJzdENoaWxkKTtcbiAgICAgICAgLy8gfVxuICAgICAgICB0aGlzLnJlbmRlck5vdGVzKHRoaXMuYXBwTm90ZXMpXG4gICAgICB9XG4gICAgfSwgMTIwKSlcblxuICAgIHRoaXMucmVuZGVyTm90ZXModGhpcy5hcHBOb3RlcylcblxuICAgIHRoaXMuaW50ZXJ2YWxJZCA9IHRoaXMucmVnaXN0ZXJJbnRlcnZhbCgxKTtcbiAgfVxuXG4gIG9udmlld3dpbGx1bmxvYWQoKSB7XG4gICAgaWYgKHRoaXMuaW50ZXJ2YWxJZCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsSWQpO1xuICAgIH1cbiAgfVxuXG4gIHJlZ2lzdGVySW50ZXJ2YWwoaWQ6IG51bWJlcik6IG51bWJlciB7XG4gICAgY29uc3QgaW50ZXJ2YWxUaW1lID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuaW50ZXJ2YWxcbiAgICByZXR1cm4gd2luZG93LnNldEludGVydmFsKGFzeW5jKCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudENoZWNrc3VtID0gYXdhaXQgdGhpcy5nZXROb3Rlc0NoZWNrc3VtKFZJVkFMRElfTk9URVNfUEFUSF9XSU4pO1xuICAgICAgY29uc29sZS5sb2coY3VycmVudENoZWNrc3VtKVxuICAgICAgLy8gSWYgdGhlIGNoZWNrc3VtIGhhcyBjaGFuZ2VkLCByZS1yZW5kZXIgdGhlIGxpc3RcbiAgICAgIGlmIChjdXJyZW50Q2hlY2tzdW0gIT09IHRoaXMucHJldmlvdXNDaGVja3N1bSkge1xuICAgICAgICBjb25zdCB7bm90ZXM6bmV3Tm90ZXNMaXN0fSA9IGF3YWl0IHRoaXMuZ2V0Tm90ZXNKU09OKFZJVkFMRElfTk9URVNfUEFUSF9XSU4pO1xuXG4gICAgICAgIHRoaXMuYXBwTm90ZXMgPSBuZXdOb3Rlc0xpc3QubWFwKChub3RlKSA9PiB7XG4gICAgICAgICAgbGV0IHRpdGxlID0gZ2V0Rmlyc3RMaW5lV2l0aG91dEhhc2gobm90ZS5jb250ZW50KTtcbiAgICAgICAgICByZXR1cm4geyAuLi5ub3RlLCB0aXRsZSB9OyAvLyBUaGlzIGNyZWF0ZXMgYSBuZXcgb2JqZWN0IHdpdGggYWxsIHByb3BlcnRpZXMgb2Ygbm90ZSBhbmQgdGhlIG5ldyB0aXRsZSBwcm9wZXJ0eVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuZnVzZSA9IG5ldyBGdXNlKHRoaXMuYXBwTm90ZXMsIHRoaXMub3B0aW9ucylcblxuICAgICAgICBsZXQgbm90ZXNMaXN0ID0gdGhpcy5hcHBOb3Rlc1xuXG4gICAgICAgIHdoaWxlICh0aGlzLnJlbmRlcmVkTGlzdD8uZmlyc3RDaGlsZCkge1xuICAgICAgICAgIHRoaXMucmVuZGVyZWRMaXN0Py5yZW1vdmVDaGlsZCh0aGlzLnJlbmRlcmVkTGlzdD8uZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCB0aGlzLnJlbmRlck5vdGVzKG5vdGVzTGlzdCk7XG4gICAgICAgIHRoaXMucHJldmlvdXNDaGVja3N1bSA9IGN1cnJlbnRDaGVja3N1bTtcbiAgICAgIH1cblxuICAgIH0sIGludGVydmFsVGltZSk7XG4gIH1cblxuICBhc3luYyByZW5kZXJOb3RlcyhsaXN0OkFwcE5vdGVbXSl7XG4gICAgYXdhaXQgbGlzdC5maWx0ZXIoKG5vdGUpID0+IG5vdGUudHlwZSA9PT0gXCJub3RlXCIgJiYgbm90ZS5jb250ZW50KS5mb3JFYWNoKChub3RlKSA9PiB7XG4gICAgICB0aGlzLnJlbmRlcmVkTGlzdD8uY3JlYXRlRWwoXCJsaVwiLCB7IHRleHQ6IG5vdGUudGl0bGUubGVuZ3RoID09IDQwID8gbm90ZS50aXRsZStcIi4uLlwiIDogbm90ZS50aXRsZSwgY2xzOlwidml2YWxkaS1ub3Rlcy1saXN0LWl0ZW1cIiwgYXR0cjp7aWQ6IG5vdGUuaWR9IH0pXG4gICAgICAgIC5vbkNsaWNrRXZlbnQoYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgaWYgKCF0aGlzLnZlcmlmeUNyZWF0ZWROb3Rlcyhub3RlLnRpdGxlKSkge1xuICAgICAgICAgICAgKGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudCkuaW5uZXJIVE1MICs9IGNoZWNrQ2lyY2xlO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVOZXdOb3RlKG5vdGUudGl0bGUsIG5vdGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBhd2FpdCB0aGlzLmFwcC52YXVsdC5vcGVuKG5vdGUudGl0bGUpO1xuICAgICAgICAgICAgdGhpcy5hcHAud29ya3NwYWNlLm9wZW5MaW5rVGV4dChub3RlLnRpdGxlLCAnJywgdHJ1ZSk7XG4gICAgICAgICAgLy8gICAoZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50KS5pbm5lckhUTUwgKz0gYDxwPlJlZXNjcmliaXI/PC9wPmA7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMudmVyaWZ5Q3JlYXRlZE5vdGVzKG5vdGUudGl0bGUpKSB7XG4gICAgICAgICAgKHRoaXMucmVuZGVyZWRMaXN0Py5sYXN0RWxlbWVudENoaWxkIGFzIEhUTUxMSUVsZW1lbnQpLmlubmVySFRNTCArPSBjaGVja0NpcmNsZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgZ2V0Tm90ZXNKU09OKHBhdGg6c3RyaW5nKTpQcm9taXNlPHtub3RlczpOb3RlW10sIGNoZWNrc3VtOiBzdHJpbmd9PiB7XG4gICAgbGV0IHN0cmluZ3BhdGggPSBwYXRoK1wiTm90ZXNcIjtcbiAgICBjb25zdCBmaWxlQ29udGVudHMgPSBhd2FpdCBmcy5yZWFkRmlsZVN5bmMoc3RyaW5ncGF0aCwgJ3V0ZjgnKTtcbiAgICBsZXQgZGF0bzpOb3RlcyA9IEpTT04ucGFyc2UoZmlsZUNvbnRlbnRzKTtcbiAgICByZXR1cm4ge25vdGVzIDogZGF0by5jaGlsZHJlbiwgY2hlY2tzdW06IGRhdG8uY2hlY2tzdW19O1xuICB9XG5cbiAgYXN5bmMgZ2V0Tm90ZXNDaGVja3N1bShwYXRoOnN0cmluZyk6UHJvbWlzZTxzdHJpbmc+IHtcbiAgICBsZXQgc3RyaW5ncGF0aCA9IHBhdGgrXCJOb3Rlc1wiO1xuICAgIGNvbnN0IGZpbGVDb250ZW50cyA9IGF3YWl0IGZzLnJlYWRGaWxlU3luYyhzdHJpbmdwYXRoKTtcbiAgICBjb25zdCBjaGVja3N1bSA9IGZpbGVDb250ZW50cy5zbGljZSgxOSw1MSkudG9TdHJpbmcoKTtcbiAgICBcbiAgICByZXR1cm4gY2hlY2tzdW07XG4gIH1cblxuICBhc3luYyBjcmVhdGVOZXdOb3RlKHRpdGxlOnN0cmluZywgbm90ZTogTm90ZSkgIHtcbiAgICBsZXQgY29udGVudCA9IHRoaXMucGx1Z2luLnNldHRpbmdzLm5vdGVzVGVtcGxhdGVcbiAgICAgIC5yZXBsYWNlKFwie3tWSVZBTERJX0dVSUR9fVwiLCBub3RlLmd1aWQgPyBub3RlLmd1aWQgOiBcIlwiKSAgXG4gICAgICAucmVwbGFjZShcInt7VklWQUxESV9JRH19XCIsIG5vdGUuaWQgPyBub3RlLmlkLnRvU3RyaW5nKCkgOiBcIlwiKSAgXG4gICAgICAucmVwbGFjZShcInt7VVJMfX1cIiwgbm90ZS51cmwgPyBub3RlLnVybCA6IFwiXCIpXG4gICAgICAucmVwbGFjZShcInt7REFURV9DUkVBVEVEfX1cIiwgbm90ZS5kYXRlX2FkZGVkID8gbmV3IERhdGUoKG5vdGUuZGF0ZV9hZGRlZC0xMTY0NDQ3MzYwMDAwMDAwMCkgLzEwMDApLnRvSVNPU3RyaW5nKCkgOiBcIlwiKVxuICAgICAgLnJlcGxhY2UoXCJ7e0NPTlRFTlR9fVwiLCBub3RlLmNvbnRlbnQgPyBub3RlLmNvbnRlbnQgOiBcIlwiKVxuXG5cbiAgICBpZihub3RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIGxldCBpbWFnZXNTdHJpbmcgPSBcIlwiXG4gICAgICBsZXQgaW1hZ2VBcnJheSA9IG5vdGUuY2hpbGRyZW4uZmlsdGVyKGNoaWxkPT5jaGlsZC50eXBlID09PSBcImF0dGFjaG1lbnRcIikubWFwKChjaGlsZCkgPT4gYFxcbjxpbWcgc3JjPVwiJHt0aGlzLnBsdWdpbi5zZXR0aW5ncy5ub3Rlc1BhdGh9XFxcXFN5bmNlZEZpbGVzXFxcXCR7Y2hpbGQuY29udGVudH1cIiB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCJhdXRvXCIvPlxcbmApXG4gICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKFwie3tJTUFHRVN9fVwiLCBpbWFnZUFycmF5LnRvU3RyaW5nKCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoXCJ7e0lNQUdFU319XCIsIFwiXCIpXG4gICAgfVxuXG5cbiAgICBsZXQgY2FycGV0YSA9IHRoaXMucGx1Z2luLnNldHRpbmdzLnZhdWx0TG9jYXRpb25cbiAgICBjYXJwZXRhICs9IHRoaXMucGx1Z2luLnNldHRpbmdzLnZhdWx0TG9jYXRpb24gPT0gXCIvXCIgPyBcIlwiIDogXCIvXCJcbiAgICBjb25zdCBzdHJpbmdwYXRoID0gY2FycGV0YSArIHRpdGxlICsgXCIubWRcIlxuICAgIGNvbnN0IG5ld05vdGUgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUoc3RyaW5ncGF0aCwgY29udGVudCk7XG4gICAgLy8gb3BlbiB0aGUgZmlsZSBhZnRlciBjcmVhdGlvblxuICAgIGF3YWl0IHRoaXMuYXBwLndvcmtzcGFjZS5vcGVuTGlua1RleHQobmV3Tm90ZS5wYXRoLCAnJywgdHJ1ZSk7XG4gICAgcmV0dXJuIG5ld05vdGU7XG4gIH0gIFxuXG4gIGFzeW5jIGdldE5vdGVGaWxlKG5vdGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPFRGaWxlPiB7XG4gICAgY29uc3QgZmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChub3RlUGF0aCk7IC8vIFRPRE8gcnVuIGFsbCB0aGUgcGF0aHMgdG8gbm9ybWFsaXplUGF0aFxuICAgIGlmICghZmlsZSB8fCAhKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmlsZSBub3QgZm91bmQ6ICR7bm90ZVBhdGh9YCk7XG4gICAgfVxuICAgIHJldHVybiBmaWxlO1xuICB9XG5cbiAgYXN5bmMgZ2V0Tm90ZXNNZXRhZGF0YShub3RlUGF0aE9SQ29udGVudFN0cmluZzpURmlsZSB8IHN0cmluZywgdHlwZTpcImZpbGVcInxcInN0cmluZ1wiKTpQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBpZiAodHlwZSA9PSBcImZpbGVcIiAmJiBub3RlUGF0aE9SQ29udGVudFN0cmluZyBpbnN0YW5jZW9mIFRGaWxlKSB7XG4gICAgICBjb25zdCBmaWxlID0gbm90ZVBhdGhPUkNvbnRlbnRTdHJpbmc7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwic3RyaW5nXCIgJiYgdHlwZW9mIG5vdGVQYXRoT1JDb250ZW50U3RyaW5nID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmFwcC52YXVsdC5yZWFkKCk7XG4gICAgfVxuICAgIGNvbnN0IGZpbGUgPSBhd2FpdCB0eXBlb2Ygbm90ZVBhdGggPT0gXCJzdHJpbmdcIiA/IG5vdGVQYXRoIDogdGhpcy5hcHAudmF1bHQucmVhZChhd2FpdCB0aGlzLmdldE5vdGVGaWxlKG5vdGVQYXRoKSkgO1xuICAgIGNvbnN0IGZyb250bWF0dGVyUmVnZXggPSAvXi0tLVxcbihbXFxzXFxTXSo/KVxcbi0tLVxcbi87XG4gICAgY29uc3QgbWF0Y2ggPSBmaWxlLm1hdGNoKGZyb250bWF0dGVyUmVnZXgpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZnJvbnRtYXR0ZXIgPSBwYXJzZVlhbWwobWF0Y2hbMV0pO1xuICAgIHJldHVybiBmcm9udG1hdHRlcjtcbiAgfSBcblxuICB2ZXJpZnlDcmVhdGVkTm90ZXModGl0bGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIC8vIENoZWNrIGlmIHRoZSBub3RlIGV4aXN0cyBpbiBPYnNpZGlhblxuICAgIGxldCBjYXJwZXRhID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MudmF1bHRMb2NhdGlvblxuICAgIGNhcnBldGEgKz0gdGhpcy5wbHVnaW4uc2V0dGluZ3MudmF1bHRMb2NhdGlvbiA9PSBcIi9cIiA/IFwiXCIgOiBcIi9cIlxuICAgIGNvbnN0IHN0cmluZ3BhdGggPSAgdGl0bGUgKyBcIi5tZFwiXG4gICAgY29uc3Qgbm90ZUV4aXN0cyA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChzdHJpbmdwYXRoKSAhPT0gbnVsbDtcbiAgICByZXR1cm4gbm90ZUV4aXN0cztcbiAgfVxuXG4gIGFzeW5jIG9uQ2xvc2UoKSB7XG4gICAgY29uc29sZS5sb2coXCJDbG9zZWQgVml2YWxkaSBOb3RlcyBWaWV3ZXIsIHN0b3BwZWQgaW50ZXJ2YWxcIilcbiAgICBpZiAodGhpcy5pbnRlcnZhbElkKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxJZCk7XG4gICAgfVxuICB9XG5cbn1cbiIsICJcblxuY29uc3QgVklWQUxESV9OT1RFU19QQVRIX1dJTiA9IFwiQzpcXFVzZXJzXFxVU1VBUklPXFxBcHBEYXRhXFxMb2NhbFxcVml2YWxkaVxcVXNlciBEYXRhXFxEZWZhdWx0XFxcXFwiO1xuY29uc3QgVklWQUxESV9OT1RFU19QQVRIX0xJTiA9IFwiL21udC9jL1VzZXJzL1VTVUFSSU8vQXBwRGF0YS9Mb2NhbC9WaXZhbGRpL1VzZXJcXCBEYXRhL0RlZmF1bHQvXCI7XG5leHBvcnQgY29uc3QgTUFYX1dJRFRIX1RJVExFID0gNjA7XG5cblxuaW50ZXJmYWNlIE5vdGUge1xuICBkYXRlX2FkZGVkOiBudW1iZXI7XG4gIGNvbnRlbnQ6IHN0cmluZztcbiAgZ3VpZDogc3RyaW5nO1xuICBpZDogbnVtYmVyO1xuICB0eXBlOiBzdHJpbmc7XG4gIHVybDogc3RyaW5nO1xuICBjaGlsZHJlbjogTm90ZVtdO1xufVxuXG5pbnRlcmZhY2UgTm90ZXMge1xuICBjaGVja3N1bTogc3RyaW5nO1xuICBjaGlsZHJlbjogTm90ZVtdO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaXJzdExpbmVXaXRob3V0SGFzaChzdHI6c3RyaW5nKTpzdHJpbmcge1xuICBjb25zdCByZWdleCA9IC9eKD86I3xcXHJ8XFxuKSpbIF0qLio/KFteXFxuXXswLDQwfSkvZ21zO1xuICBpZiAoc3RyID09IFwiXCIgfHwgc3RyID09IG51bGwpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBjb25zdCBtYXRjaCA9IHJlZ2V4LmV4ZWMoc3RyKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgbGV0IGZpcnN0TGluZT0gbWF0Y2hbMV0ucmVwbGFjZSgvW1xcXFxcXC88Pjp8P1wiLV0vZywgJycpO1xuICAgIHJldHVybiBmaXJzdExpbmUucmVwbGFjZSgvWy5cXHNdKyQvLCAnJyk7XG4gIH1cblxuICByZXR1cm4gXCJcIjtcbn1cblxuXG5cbi8vIGdldEZpcnN0TGluZVdpdGhvdXRIYXNoKFwiIyBQZWxpY3VsYXMgUXVlIFZlclxcblxcbi0gVGVuIExpdHRsZSBNaXN0cmVzc1xcbi0gaGlzIE9ubHkgU29uXFxuLSBKaG9uIFdlZWsgNFxcbi0gQ2l0YWRlbCBcXG4tIE9oIGJlbGluZGFcXG4tIEN1YW50dW0gbWFuXHUwMEVEYVxcbi0gU2VuZWNhXFxuLSBHaG9zdGVkIFxcbi0gT3RoZXIgcGVvcGxlXFxuLSBUaGUgcG9wZSBFeG9yY2lzdFxcbi0gQmF0bWFuIERvb21cXG4tIER1bmdlb25zIEFuZCBEcmFnb25zXCIpXG5cblxuXG4vLyBnZXROb3Rlc0pTT04oKSIsICIvKipcbiAqIEZ1c2UuanMgdjcuMC4wIC0gTGlnaHR3ZWlnaHQgZnV6enktc2VhcmNoIChodHRwOi8vZnVzZWpzLmlvKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAyMyBLaXJvIFJpc2sgKGh0dHA6Ly9raXJvLm1lKVxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC4gQXBhY2hlIFNvZnR3YXJlIExpY2Vuc2UgMi4wXG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gIUFycmF5LmlzQXJyYXlcbiAgICA/IGdldFRhZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgICA6IEFycmF5LmlzQXJyYXkodmFsdWUpXG59XG5cbi8vIEFkYXB0ZWQgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi9tYXN0ZXIvLmludGVybmFsL2Jhc2VUb1N0cmluZy5qc1xuY29uc3QgSU5GSU5JVFkgPSAxIC8gMDtcbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbiAgbGV0IHJlc3VsdCA9IHZhbHVlICsgJyc7XG4gIHJldHVybiByZXN1bHQgPT0gJzAnICYmIDEgLyB2YWx1ZSA9PSAtSU5GSU5JVFkgPyAnLTAnIDogcmVzdWx0XG59XG5cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnXG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInXG59XG5cbi8vIEFkYXB0ZWQgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi9tYXN0ZXIvaXNCb29sZWFuLmpzXG5mdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSA9PT0gdHJ1ZSB8fFxuICAgIHZhbHVlID09PSBmYWxzZSB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gJ1tvYmplY3QgQm9vbGVhbl0nKVxuICApXG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnXG59XG5cbi8vIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLlxuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgdmFsdWUgIT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzQmxhbmsodmFsdWUpIHtcbiAgcmV0dXJuICF2YWx1ZS50cmltKCkubGVuZ3RoXG59XG5cbi8vIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbi8vIEFkYXB0ZWQgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi9tYXN0ZXIvLmludGVybmFsL2dldFRhZy5qc1xuZnVuY3Rpb24gZ2V0VGFnKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsXG4gICAgPyB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICA/ICdbb2JqZWN0IFVuZGVmaW5lZF0nXG4gICAgICA6ICdbb2JqZWN0IE51bGxdJ1xuICAgIDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKVxufVxuXG5jb25zdCBFWFRFTkRFRF9TRUFSQ0hfVU5BVkFJTEFCTEUgPSAnRXh0ZW5kZWQgc2VhcmNoIGlzIG5vdCBhdmFpbGFibGUnO1xuXG5jb25zdCBJTkNPUlJFQ1RfSU5ERVhfVFlQRSA9IFwiSW5jb3JyZWN0ICdpbmRleCcgdHlwZVwiO1xuXG5jb25zdCBMT0dJQ0FMX1NFQVJDSF9JTlZBTElEX1FVRVJZX0ZPUl9LRVkgPSAoa2V5KSA9PlxuICBgSW52YWxpZCB2YWx1ZSBmb3Iga2V5ICR7a2V5fWA7XG5cbmNvbnN0IFBBVFRFUk5fTEVOR1RIX1RPT19MQVJHRSA9IChtYXgpID0+XG4gIGBQYXR0ZXJuIGxlbmd0aCBleGNlZWRzIG1heCBvZiAke21heH0uYDtcblxuY29uc3QgTUlTU0lOR19LRVlfUFJPUEVSVFkgPSAobmFtZSkgPT4gYE1pc3NpbmcgJHtuYW1lfSBwcm9wZXJ0eSBpbiBrZXlgO1xuXG5jb25zdCBJTlZBTElEX0tFWV9XRUlHSFRfVkFMVUUgPSAoa2V5KSA9PlxuICBgUHJvcGVydHkgJ3dlaWdodCcgaW4ga2V5ICcke2tleX0nIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyYDtcblxuY29uc3QgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuY2xhc3MgS2V5U3RvcmUge1xuICBjb25zdHJ1Y3RvcihrZXlzKSB7XG4gICAgdGhpcy5fa2V5cyA9IFtdO1xuICAgIHRoaXMuX2tleU1hcCA9IHt9O1xuXG4gICAgbGV0IHRvdGFsV2VpZ2h0ID0gMDtcblxuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBsZXQgb2JqID0gY3JlYXRlS2V5KGtleSk7XG5cbiAgICAgIHRoaXMuX2tleXMucHVzaChvYmopO1xuICAgICAgdGhpcy5fa2V5TWFwW29iai5pZF0gPSBvYmo7XG5cbiAgICAgIHRvdGFsV2VpZ2h0ICs9IG9iai53ZWlnaHQ7XG4gICAgfSk7XG5cbiAgICAvLyBOb3JtYWxpemUgd2VpZ2h0cyBzbyB0aGF0IHRoZWlyIHN1bSBpcyBlcXVhbCB0byAxXG4gICAgdGhpcy5fa2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGtleS53ZWlnaHQgLz0gdG90YWxXZWlnaHQ7XG4gICAgfSk7XG4gIH1cbiAgZ2V0KGtleUlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2tleU1hcFtrZXlJZF1cbiAgfVxuICBrZXlzKCkge1xuICAgIHJldHVybiB0aGlzLl9rZXlzXG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLl9rZXlzKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleShrZXkpIHtcbiAgbGV0IHBhdGggPSBudWxsO1xuICBsZXQgaWQgPSBudWxsO1xuICBsZXQgc3JjID0gbnVsbDtcbiAgbGV0IHdlaWdodCA9IDE7XG4gIGxldCBnZXRGbiA9IG51bGw7XG5cbiAgaWYgKGlzU3RyaW5nKGtleSkgfHwgaXNBcnJheShrZXkpKSB7XG4gICAgc3JjID0ga2V5O1xuICAgIHBhdGggPSBjcmVhdGVLZXlQYXRoKGtleSk7XG4gICAgaWQgPSBjcmVhdGVLZXlJZChrZXkpO1xuICB9IGVsc2Uge1xuICAgIGlmICghaGFzT3duLmNhbGwoa2V5LCAnbmFtZScpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoTUlTU0lOR19LRVlfUFJPUEVSVFkoJ25hbWUnKSlcbiAgICB9XG5cbiAgICBjb25zdCBuYW1lID0ga2V5Lm5hbWU7XG4gICAgc3JjID0gbmFtZTtcblxuICAgIGlmIChoYXNPd24uY2FsbChrZXksICd3ZWlnaHQnKSkge1xuICAgICAgd2VpZ2h0ID0ga2V5LndlaWdodDtcblxuICAgICAgaWYgKHdlaWdodCA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX0tFWV9XRUlHSFRfVkFMVUUobmFtZSkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcGF0aCA9IGNyZWF0ZUtleVBhdGgobmFtZSk7XG4gICAgaWQgPSBjcmVhdGVLZXlJZChuYW1lKTtcbiAgICBnZXRGbiA9IGtleS5nZXRGbjtcbiAgfVxuXG4gIHJldHVybiB7IHBhdGgsIGlkLCB3ZWlnaHQsIHNyYywgZ2V0Rm4gfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlQYXRoKGtleSkge1xuICByZXR1cm4gaXNBcnJheShrZXkpID8ga2V5IDoga2V5LnNwbGl0KCcuJylcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5SWQoa2V5KSB7XG4gIHJldHVybiBpc0FycmF5KGtleSkgPyBrZXkuam9pbignLicpIDoga2V5XG59XG5cbmZ1bmN0aW9uIGdldChvYmosIHBhdGgpIHtcbiAgbGV0IGxpc3QgPSBbXTtcbiAgbGV0IGFyciA9IGZhbHNlO1xuXG4gIGNvbnN0IGRlZXBHZXQgPSAob2JqLCBwYXRoLCBpbmRleCkgPT4ge1xuICAgIGlmICghaXNEZWZpbmVkKG9iaikpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoIXBhdGhbaW5kZXhdKSB7XG4gICAgICAvLyBJZiB0aGVyZSdzIG5vIHBhdGggbGVmdCwgd2UndmUgYXJyaXZlZCBhdCB0aGUgb2JqZWN0IHdlIGNhcmUgYWJvdXQuXG4gICAgICBsaXN0LnB1c2gob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGtleSA9IHBhdGhbaW5kZXhdO1xuXG4gICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuXG4gICAgICBpZiAoIWlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlJ3JlIGF0IHRoZSBsYXN0IHZhbHVlIGluIHRoZSBwYXRoLCBhbmQgaWYgaXQncyBhIHN0cmluZy9udW1iZXIvYm9vbCxcbiAgICAgIC8vIGFkZCBpdCB0byB0aGUgbGlzdFxuICAgICAgaWYgKFxuICAgICAgICBpbmRleCA9PT0gcGF0aC5sZW5ndGggLSAxICYmXG4gICAgICAgIChpc1N0cmluZyh2YWx1ZSkgfHwgaXNOdW1iZXIodmFsdWUpIHx8IGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgICApIHtcbiAgICAgICAgbGlzdC5wdXNoKHRvU3RyaW5nKHZhbHVlKSk7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGFyciA9IHRydWU7XG4gICAgICAgIC8vIFNlYXJjaCBlYWNoIGl0ZW0gaW4gdGhlIGFycmF5LlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBkZWVwR2V0KHZhbHVlW2ldLCBwYXRoLCBpbmRleCArIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhdGgubGVuZ3RoKSB7XG4gICAgICAgIC8vIEFuIG9iamVjdC4gUmVjdXJzZSBmdXJ0aGVyLlxuICAgICAgICBkZWVwR2V0KHZhbHVlLCBwYXRoLCBpbmRleCArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAoc2luY2UgcGF0aCB1c2VkIHRvIGJlIGEgc3RyaW5nKVxuICBkZWVwR2V0KG9iaiwgaXNTdHJpbmcocGF0aCkgPyBwYXRoLnNwbGl0KCcuJykgOiBwYXRoLCAwKTtcblxuICByZXR1cm4gYXJyID8gbGlzdCA6IGxpc3RbMF1cbn1cblxuY29uc3QgTWF0Y2hPcHRpb25zID0ge1xuICAvLyBXaGV0aGVyIHRoZSBtYXRjaGVzIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0IHNldC4gV2hlbiBgdHJ1ZWAsIGVhY2ggcmVjb3JkIGluIHRoZSByZXN1bHRcbiAgLy8gc2V0IHdpbGwgaW5jbHVkZSB0aGUgaW5kaWNlcyBvZiB0aGUgbWF0Y2hlZCBjaGFyYWN0ZXJzLlxuICAvLyBUaGVzZSBjYW4gY29uc2VxdWVudGx5IGJlIHVzZWQgZm9yIGhpZ2hsaWdodGluZyBwdXJwb3Nlcy5cbiAgaW5jbHVkZU1hdGNoZXM6IGZhbHNlLFxuICAvLyBXaGVuIGB0cnVlYCwgdGhlIG1hdGNoaW5nIGZ1bmN0aW9uIHdpbGwgY29udGludWUgdG8gdGhlIGVuZCBvZiBhIHNlYXJjaCBwYXR0ZXJuIGV2ZW4gaWZcbiAgLy8gYSBwZXJmZWN0IG1hdGNoIGhhcyBhbHJlYWR5IGJlZW4gbG9jYXRlZCBpbiB0aGUgc3RyaW5nLlxuICBmaW5kQWxsTWF0Y2hlczogZmFsc2UsXG4gIC8vIE1pbmltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCBtdXN0IGJlIG1hdGNoZWQgYmVmb3JlIGEgcmVzdWx0IGlzIGNvbnNpZGVyZWQgYSBtYXRjaFxuICBtaW5NYXRjaENoYXJMZW5ndGg6IDFcbn07XG5cbmNvbnN0IEJhc2ljT3B0aW9ucyA9IHtcbiAgLy8gV2hlbiBgdHJ1ZWAsIHRoZSBhbGdvcml0aG0gY29udGludWVzIHNlYXJjaGluZyB0byB0aGUgZW5kIG9mIHRoZSBpbnB1dCBldmVuIGlmIGEgcGVyZmVjdFxuICAvLyBtYXRjaCBpcyBmb3VuZCBiZWZvcmUgdGhlIGVuZCBvZiB0aGUgc2FtZSBpbnB1dC5cbiAgaXNDYXNlU2Vuc2l0aXZlOiBmYWxzZSxcbiAgLy8gV2hlbiB0cnVlLCB0aGUgbWF0Y2hpbmcgZnVuY3Rpb24gd2lsbCBjb250aW51ZSB0byB0aGUgZW5kIG9mIGEgc2VhcmNoIHBhdHRlcm4gZXZlbiBpZlxuICBpbmNsdWRlU2NvcmU6IGZhbHNlLFxuICAvLyBMaXN0IG9mIHByb3BlcnRpZXMgdGhhdCB3aWxsIGJlIHNlYXJjaGVkLiBUaGlzIGFsc28gc3VwcG9ydHMgbmVzdGVkIHByb3BlcnRpZXMuXG4gIGtleXM6IFtdLFxuICAvLyBXaGV0aGVyIHRvIHNvcnQgdGhlIHJlc3VsdCBsaXN0LCBieSBzY29yZVxuICBzaG91bGRTb3J0OiB0cnVlLFxuICAvLyBEZWZhdWx0IHNvcnQgZnVuY3Rpb246IHNvcnQgYnkgYXNjZW5kaW5nIHNjb3JlLCBhc2NlbmRpbmcgaW5kZXhcbiAgc29ydEZuOiAoYSwgYikgPT5cbiAgICBhLnNjb3JlID09PSBiLnNjb3JlID8gKGEuaWR4IDwgYi5pZHggPyAtMSA6IDEpIDogYS5zY29yZSA8IGIuc2NvcmUgPyAtMSA6IDFcbn07XG5cbmNvbnN0IEZ1enp5T3B0aW9ucyA9IHtcbiAgLy8gQXBwcm94aW1hdGVseSB3aGVyZSBpbiB0aGUgdGV4dCBpcyB0aGUgcGF0dGVybiBleHBlY3RlZCB0byBiZSBmb3VuZD9cbiAgbG9jYXRpb246IDAsXG4gIC8vIEF0IHdoYXQgcG9pbnQgZG9lcyB0aGUgbWF0Y2ggYWxnb3JpdGhtIGdpdmUgdXAuIEEgdGhyZXNob2xkIG9mICcwLjAnIHJlcXVpcmVzIGEgcGVyZmVjdCBtYXRjaFxuICAvLyAob2YgYm90aCBsZXR0ZXJzIGFuZCBsb2NhdGlvbiksIGEgdGhyZXNob2xkIG9mICcxLjAnIHdvdWxkIG1hdGNoIGFueXRoaW5nLlxuICB0aHJlc2hvbGQ6IDAuNixcbiAgLy8gRGV0ZXJtaW5lcyBob3cgY2xvc2UgdGhlIG1hdGNoIG11c3QgYmUgdG8gdGhlIGZ1enp5IGxvY2F0aW9uIChzcGVjaWZpZWQgYWJvdmUpLlxuICAvLyBBbiBleGFjdCBsZXR0ZXIgbWF0Y2ggd2hpY2ggaXMgJ2Rpc3RhbmNlJyBjaGFyYWN0ZXJzIGF3YXkgZnJvbSB0aGUgZnV6enkgbG9jYXRpb25cbiAgLy8gd291bGQgc2NvcmUgYXMgYSBjb21wbGV0ZSBtaXNtYXRjaC4gQSBkaXN0YW5jZSBvZiAnMCcgcmVxdWlyZXMgdGhlIG1hdGNoIGJlIGF0XG4gIC8vIHRoZSBleGFjdCBsb2NhdGlvbiBzcGVjaWZpZWQsIGEgdGhyZXNob2xkIG9mICcxMDAwJyB3b3VsZCByZXF1aXJlIGEgcGVyZmVjdCBtYXRjaFxuICAvLyB0byBiZSB3aXRoaW4gODAwIGNoYXJhY3RlcnMgb2YgdGhlIGZ1enp5IGxvY2F0aW9uIHRvIGJlIGZvdW5kIHVzaW5nIGEgMC44IHRocmVzaG9sZC5cbiAgZGlzdGFuY2U6IDEwMFxufTtcblxuY29uc3QgQWR2YW5jZWRPcHRpb25zID0ge1xuICAvLyBXaGVuIGB0cnVlYCwgaXQgZW5hYmxlcyB0aGUgdXNlIG9mIHVuaXgtbGlrZSBzZWFyY2ggY29tbWFuZHNcbiAgdXNlRXh0ZW5kZWRTZWFyY2g6IGZhbHNlLFxuICAvLyBUaGUgZ2V0IGZ1bmN0aW9uIHRvIHVzZSB3aGVuIGZldGNoaW5nIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIC8vIFRoZSBkZWZhdWx0IHdpbGwgc2VhcmNoIG5lc3RlZCBwYXRocyAqaWUgZm9vLmJhci5iYXoqXG4gIGdldEZuOiBnZXQsXG4gIC8vIFdoZW4gYHRydWVgLCBzZWFyY2ggd2lsbCBpZ25vcmUgYGxvY2F0aW9uYCBhbmQgYGRpc3RhbmNlYCwgc28gaXQgd29uJ3QgbWF0dGVyXG4gIC8vIHdoZXJlIGluIHRoZSBzdHJpbmcgdGhlIHBhdHRlcm4gYXBwZWFycy5cbiAgLy8gTW9yZSBpbmZvOiBodHRwczovL2Z1c2Vqcy5pby9jb25jZXB0cy9zY29yaW5nLXRoZW9yeS5odG1sI2Z1enppbmVzcy1zY29yZVxuICBpZ25vcmVMb2NhdGlvbjogZmFsc2UsXG4gIC8vIFdoZW4gYHRydWVgLCB0aGUgY2FsY3VsYXRpb24gZm9yIHRoZSByZWxldmFuY2Ugc2NvcmUgKHVzZWQgZm9yIHNvcnRpbmcpIHdpbGxcbiAgLy8gaWdub3JlIHRoZSBmaWVsZC1sZW5ndGggbm9ybS5cbiAgLy8gTW9yZSBpbmZvOiBodHRwczovL2Z1c2Vqcy5pby9jb25jZXB0cy9zY29yaW5nLXRoZW9yeS5odG1sI2ZpZWxkLWxlbmd0aC1ub3JtXG4gIGlnbm9yZUZpZWxkTm9ybTogZmFsc2UsXG4gIC8vIFRoZSB3ZWlnaHQgdG8gZGV0ZXJtaW5lIGhvdyBtdWNoIGZpZWxkIGxlbmd0aCBub3JtIGVmZmVjdHMgc2NvcmluZy5cbiAgZmllbGROb3JtV2VpZ2h0OiAxXG59O1xuXG52YXIgQ29uZmlnID0ge1xuICAuLi5CYXNpY09wdGlvbnMsXG4gIC4uLk1hdGNoT3B0aW9ucyxcbiAgLi4uRnV6enlPcHRpb25zLFxuICAuLi5BZHZhbmNlZE9wdGlvbnNcbn07XG5cbmNvbnN0IFNQQUNFID0gL1teIF0rL2c7XG5cbi8vIEZpZWxkLWxlbmd0aCBub3JtOiB0aGUgc2hvcnRlciB0aGUgZmllbGQsIHRoZSBoaWdoZXIgdGhlIHdlaWdodC5cbi8vIFNldCB0byAzIGRlY2ltYWxzIHRvIHJlZHVjZSBpbmRleCBzaXplLlxuZnVuY3Rpb24gbm9ybSh3ZWlnaHQgPSAxLCBtYW50aXNzYSA9IDMpIHtcbiAgY29uc3QgY2FjaGUgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IG0gPSBNYXRoLnBvdygxMCwgbWFudGlzc2EpO1xuXG4gIHJldHVybiB7XG4gICAgZ2V0KHZhbHVlKSB7XG4gICAgICBjb25zdCBudW1Ub2tlbnMgPSB2YWx1ZS5tYXRjaChTUEFDRSkubGVuZ3RoO1xuXG4gICAgICBpZiAoY2FjaGUuaGFzKG51bVRva2VucykpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlLmdldChudW1Ub2tlbnMpXG4gICAgICB9XG5cbiAgICAgIC8vIERlZmF1bHQgZnVuY3Rpb24gaXMgMS9zcXJ0KHgpLCB3ZWlnaHQgbWFrZXMgdGhhdCB2YXJpYWJsZVxuICAgICAgY29uc3Qgbm9ybSA9IDEgLyBNYXRoLnBvdyhudW1Ub2tlbnMsIDAuNSAqIHdlaWdodCk7XG5cbiAgICAgIC8vIEluIHBsYWNlIG9mIGB0b0ZpeGVkKG1hbnRpc3NhKWAsIGZvciBmYXN0ZXIgY29tcHV0YXRpb25cbiAgICAgIGNvbnN0IG4gPSBwYXJzZUZsb2F0KE1hdGgucm91bmQobm9ybSAqIG0pIC8gbSk7XG5cbiAgICAgIGNhY2hlLnNldChudW1Ub2tlbnMsIG4pO1xuXG4gICAgICByZXR1cm4gblxuICAgIH0sXG4gICAgY2xlYXIoKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBGdXNlSW5kZXgge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZ2V0Rm4gPSBDb25maWcuZ2V0Rm4sXG4gICAgZmllbGROb3JtV2VpZ2h0ID0gQ29uZmlnLmZpZWxkTm9ybVdlaWdodFxuICB9ID0ge30pIHtcbiAgICB0aGlzLm5vcm0gPSBub3JtKGZpZWxkTm9ybVdlaWdodCwgMyk7XG4gICAgdGhpcy5nZXRGbiA9IGdldEZuO1xuICAgIHRoaXMuaXNDcmVhdGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLnNldEluZGV4UmVjb3JkcygpO1xuICB9XG4gIHNldFNvdXJjZXMoZG9jcyA9IFtdKSB7XG4gICAgdGhpcy5kb2NzID0gZG9jcztcbiAgfVxuICBzZXRJbmRleFJlY29yZHMocmVjb3JkcyA9IFtdKSB7XG4gICAgdGhpcy5yZWNvcmRzID0gcmVjb3JkcztcbiAgfVxuICBzZXRLZXlzKGtleXMgPSBbXSkge1xuICAgIHRoaXMua2V5cyA9IGtleXM7XG4gICAgdGhpcy5fa2V5c01hcCA9IHt9O1xuICAgIGtleXMuZm9yRWFjaCgoa2V5LCBpZHgpID0+IHtcbiAgICAgIHRoaXMuX2tleXNNYXBba2V5LmlkXSA9IGlkeDtcbiAgICB9KTtcbiAgfVxuICBjcmVhdGUoKSB7XG4gICAgaWYgKHRoaXMuaXNDcmVhdGVkIHx8ICF0aGlzLmRvY3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmlzQ3JlYXRlZCA9IHRydWU7XG5cbiAgICAvLyBMaXN0IGlzIEFycmF5PFN0cmluZz5cbiAgICBpZiAoaXNTdHJpbmcodGhpcy5kb2NzWzBdKSkge1xuICAgICAgdGhpcy5kb2NzLmZvckVhY2goKGRvYywgZG9jSW5kZXgpID0+IHtcbiAgICAgICAgdGhpcy5fYWRkU3RyaW5nKGRvYywgZG9jSW5kZXgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExpc3QgaXMgQXJyYXk8T2JqZWN0PlxuICAgICAgdGhpcy5kb2NzLmZvckVhY2goKGRvYywgZG9jSW5kZXgpID0+IHtcbiAgICAgICAgdGhpcy5fYWRkT2JqZWN0KGRvYywgZG9jSW5kZXgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5ub3JtLmNsZWFyKCk7XG4gIH1cbiAgLy8gQWRkcyBhIGRvYyB0byB0aGUgZW5kIG9mIHRoZSBpbmRleFxuICBhZGQoZG9jKSB7XG4gICAgY29uc3QgaWR4ID0gdGhpcy5zaXplKCk7XG5cbiAgICBpZiAoaXNTdHJpbmcoZG9jKSkge1xuICAgICAgdGhpcy5fYWRkU3RyaW5nKGRvYywgaWR4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYWRkT2JqZWN0KGRvYywgaWR4KTtcbiAgICB9XG4gIH1cbiAgLy8gUmVtb3ZlcyB0aGUgZG9jIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXggb2YgdGhlIGluZGV4XG4gIHJlbW92ZUF0KGlkeCkge1xuICAgIHRoaXMucmVjb3Jkcy5zcGxpY2UoaWR4LCAxKTtcblxuICAgIC8vIENoYW5nZSByZWYgaW5kZXggb2YgZXZlcnkgc3Vic3F1ZW50IGRvY1xuICAgIGZvciAobGV0IGkgPSBpZHgsIGxlbiA9IHRoaXMuc2l6ZSgpOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHRoaXMucmVjb3Jkc1tpXS5pIC09IDE7XG4gICAgfVxuICB9XG4gIGdldFZhbHVlRm9ySXRlbUF0S2V5SWQoaXRlbSwga2V5SWQpIHtcbiAgICByZXR1cm4gaXRlbVt0aGlzLl9rZXlzTWFwW2tleUlkXV1cbiAgfVxuICBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLnJlY29yZHMubGVuZ3RoXG4gIH1cbiAgX2FkZFN0cmluZyhkb2MsIGRvY0luZGV4KSB7XG4gICAgaWYgKCFpc0RlZmluZWQoZG9jKSB8fCBpc0JsYW5rKGRvYykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCByZWNvcmQgPSB7XG4gICAgICB2OiBkb2MsXG4gICAgICBpOiBkb2NJbmRleCxcbiAgICAgIG46IHRoaXMubm9ybS5nZXQoZG9jKVxuICAgIH07XG5cbiAgICB0aGlzLnJlY29yZHMucHVzaChyZWNvcmQpO1xuICB9XG4gIF9hZGRPYmplY3QoZG9jLCBkb2NJbmRleCkge1xuICAgIGxldCByZWNvcmQgPSB7IGk6IGRvY0luZGV4LCAkOiB7fSB9O1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIGV2ZXJ5IGtleSAoaS5lLCBwYXRoKSwgYW5kIGZldGNoIHRoZSB2YWx1ZSBhdCB0aGF0IGtleVxuICAgIHRoaXMua2V5cy5mb3JFYWNoKChrZXksIGtleUluZGV4KSA9PiB7XG4gICAgICBsZXQgdmFsdWUgPSBrZXkuZ2V0Rm4gPyBrZXkuZ2V0Rm4oZG9jKSA6IHRoaXMuZ2V0Rm4oZG9jLCBrZXkucGF0aCk7XG5cbiAgICAgIGlmICghaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGxldCBzdWJSZWNvcmRzID0gW107XG4gICAgICAgIGNvbnN0IHN0YWNrID0gW3sgbmVzdGVkQXJySW5kZXg6IC0xLCB2YWx1ZSB9XTtcblxuICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgeyBuZXN0ZWRBcnJJbmRleCwgdmFsdWUgfSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgICAgaWYgKCFpc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkgJiYgIWlzQmxhbmsodmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgc3ViUmVjb3JkID0ge1xuICAgICAgICAgICAgICB2OiB2YWx1ZSxcbiAgICAgICAgICAgICAgaTogbmVzdGVkQXJySW5kZXgsXG4gICAgICAgICAgICAgIG46IHRoaXMubm9ybS5nZXQodmFsdWUpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzdWJSZWNvcmRzLnB1c2goc3ViUmVjb3JkKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKChpdGVtLCBrKSA9PiB7XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgIG5lc3RlZEFyckluZGV4OiBrLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBpdGVtXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIDtcbiAgICAgICAgfVxuICAgICAgICByZWNvcmQuJFtrZXlJbmRleF0gPSBzdWJSZWNvcmRzO1xuICAgICAgfSBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkgJiYgIWlzQmxhbmsodmFsdWUpKSB7XG4gICAgICAgIGxldCBzdWJSZWNvcmQgPSB7XG4gICAgICAgICAgdjogdmFsdWUsXG4gICAgICAgICAgbjogdGhpcy5ub3JtLmdldCh2YWx1ZSlcbiAgICAgICAgfTtcblxuICAgICAgICByZWNvcmQuJFtrZXlJbmRleF0gPSBzdWJSZWNvcmQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlY29yZHMucHVzaChyZWNvcmQpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5czogdGhpcy5rZXlzLFxuICAgICAgcmVjb3JkczogdGhpcy5yZWNvcmRzXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUluZGV4KFxuICBrZXlzLFxuICBkb2NzLFxuICB7IGdldEZuID0gQ29uZmlnLmdldEZuLCBmaWVsZE5vcm1XZWlnaHQgPSBDb25maWcuZmllbGROb3JtV2VpZ2h0IH0gPSB7fVxuKSB7XG4gIGNvbnN0IG15SW5kZXggPSBuZXcgRnVzZUluZGV4KHsgZ2V0Rm4sIGZpZWxkTm9ybVdlaWdodCB9KTtcbiAgbXlJbmRleC5zZXRLZXlzKGtleXMubWFwKGNyZWF0ZUtleSkpO1xuICBteUluZGV4LnNldFNvdXJjZXMoZG9jcyk7XG4gIG15SW5kZXguY3JlYXRlKCk7XG4gIHJldHVybiBteUluZGV4XG59XG5cbmZ1bmN0aW9uIHBhcnNlSW5kZXgoXG4gIGRhdGEsXG4gIHsgZ2V0Rm4gPSBDb25maWcuZ2V0Rm4sIGZpZWxkTm9ybVdlaWdodCA9IENvbmZpZy5maWVsZE5vcm1XZWlnaHQgfSA9IHt9XG4pIHtcbiAgY29uc3QgeyBrZXlzLCByZWNvcmRzIH0gPSBkYXRhO1xuICBjb25zdCBteUluZGV4ID0gbmV3IEZ1c2VJbmRleCh7IGdldEZuLCBmaWVsZE5vcm1XZWlnaHQgfSk7XG4gIG15SW5kZXguc2V0S2V5cyhrZXlzKTtcbiAgbXlJbmRleC5zZXRJbmRleFJlY29yZHMocmVjb3Jkcyk7XG4gIHJldHVybiBteUluZGV4XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVTY29yZSQxKFxuICBwYXR0ZXJuLFxuICB7XG4gICAgZXJyb3JzID0gMCxcbiAgICBjdXJyZW50TG9jYXRpb24gPSAwLFxuICAgIGV4cGVjdGVkTG9jYXRpb24gPSAwLFxuICAgIGRpc3RhbmNlID0gQ29uZmlnLmRpc3RhbmNlLFxuICAgIGlnbm9yZUxvY2F0aW9uID0gQ29uZmlnLmlnbm9yZUxvY2F0aW9uXG4gIH0gPSB7fVxuKSB7XG4gIGNvbnN0IGFjY3VyYWN5ID0gZXJyb3JzIC8gcGF0dGVybi5sZW5ndGg7XG5cbiAgaWYgKGlnbm9yZUxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGFjY3VyYWN5XG4gIH1cblxuICBjb25zdCBwcm94aW1pdHkgPSBNYXRoLmFicyhleHBlY3RlZExvY2F0aW9uIC0gY3VycmVudExvY2F0aW9uKTtcblxuICBpZiAoIWRpc3RhbmNlKSB7XG4gICAgLy8gRG9kZ2UgZGl2aWRlIGJ5IHplcm8gZXJyb3IuXG4gICAgcmV0dXJuIHByb3hpbWl0eSA/IDEuMCA6IGFjY3VyYWN5XG4gIH1cblxuICByZXR1cm4gYWNjdXJhY3kgKyBwcm94aW1pdHkgLyBkaXN0YW5jZVxufVxuXG5mdW5jdGlvbiBjb252ZXJ0TWFza1RvSW5kaWNlcyhcbiAgbWF0Y2htYXNrID0gW10sXG4gIG1pbk1hdGNoQ2hhckxlbmd0aCA9IENvbmZpZy5taW5NYXRjaENoYXJMZW5ndGhcbikge1xuICBsZXQgaW5kaWNlcyA9IFtdO1xuICBsZXQgc3RhcnQgPSAtMTtcbiAgbGV0IGVuZCA9IC0xO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yIChsZXQgbGVuID0gbWF0Y2htYXNrLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgbGV0IG1hdGNoID0gbWF0Y2htYXNrW2ldO1xuICAgIGlmIChtYXRjaCAmJiBzdGFydCA9PT0gLTEpIHtcbiAgICAgIHN0YXJ0ID0gaTtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaCAmJiBzdGFydCAhPT0gLTEpIHtcbiAgICAgIGVuZCA9IGkgLSAxO1xuICAgICAgaWYgKGVuZCAtIHN0YXJ0ICsgMSA+PSBtaW5NYXRjaENoYXJMZW5ndGgpIHtcbiAgICAgICAgaW5kaWNlcy5wdXNoKFtzdGFydCwgZW5kXSk7XG4gICAgICB9XG4gICAgICBzdGFydCA9IC0xO1xuICAgIH1cbiAgfVxuXG4gIC8vIChpLTEgLSBzdGFydCkgKyAxID0+IGkgLSBzdGFydFxuICBpZiAobWF0Y2htYXNrW2kgLSAxXSAmJiBpIC0gc3RhcnQgPj0gbWluTWF0Y2hDaGFyTGVuZ3RoKSB7XG4gICAgaW5kaWNlcy5wdXNoKFtzdGFydCwgaSAtIDFdKTtcbiAgfVxuXG4gIHJldHVybiBpbmRpY2VzXG59XG5cbi8vIE1hY2hpbmUgd29yZCBzaXplXG5jb25zdCBNQVhfQklUUyA9IDMyO1xuXG5mdW5jdGlvbiBzZWFyY2goXG4gIHRleHQsXG4gIHBhdHRlcm4sXG4gIHBhdHRlcm5BbHBoYWJldCxcbiAge1xuICAgIGxvY2F0aW9uID0gQ29uZmlnLmxvY2F0aW9uLFxuICAgIGRpc3RhbmNlID0gQ29uZmlnLmRpc3RhbmNlLFxuICAgIHRocmVzaG9sZCA9IENvbmZpZy50aHJlc2hvbGQsXG4gICAgZmluZEFsbE1hdGNoZXMgPSBDb25maWcuZmluZEFsbE1hdGNoZXMsXG4gICAgbWluTWF0Y2hDaGFyTGVuZ3RoID0gQ29uZmlnLm1pbk1hdGNoQ2hhckxlbmd0aCxcbiAgICBpbmNsdWRlTWF0Y2hlcyA9IENvbmZpZy5pbmNsdWRlTWF0Y2hlcyxcbiAgICBpZ25vcmVMb2NhdGlvbiA9IENvbmZpZy5pZ25vcmVMb2NhdGlvblxuICB9ID0ge31cbikge1xuICBpZiAocGF0dGVybi5sZW5ndGggPiBNQVhfQklUUykge1xuICAgIHRocm93IG5ldyBFcnJvcihQQVRURVJOX0xFTkdUSF9UT09fTEFSR0UoTUFYX0JJVFMpKVxuICB9XG5cbiAgY29uc3QgcGF0dGVybkxlbiA9IHBhdHRlcm4ubGVuZ3RoO1xuICAvLyBTZXQgc3RhcnRpbmcgbG9jYXRpb24gYXQgYmVnaW5uaW5nIHRleHQgYW5kIGluaXRpYWxpemUgdGhlIGFscGhhYmV0LlxuICBjb25zdCB0ZXh0TGVuID0gdGV4dC5sZW5ndGg7XG4gIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVuIGxvY2F0aW9uID4gdGV4dC5sZW5ndGhcbiAgY29uc3QgZXhwZWN0ZWRMb2NhdGlvbiA9IE1hdGgubWF4KDAsIE1hdGgubWluKGxvY2F0aW9uLCB0ZXh0TGVuKSk7XG4gIC8vIEhpZ2hlc3Qgc2NvcmUgYmV5b25kIHdoaWNoIHdlIGdpdmUgdXAuXG4gIGxldCBjdXJyZW50VGhyZXNob2xkID0gdGhyZXNob2xkO1xuICAvLyBJcyB0aGVyZSBhIG5lYXJieSBleGFjdCBtYXRjaD8gKHNwZWVkdXApXG4gIGxldCBiZXN0TG9jYXRpb24gPSBleHBlY3RlZExvY2F0aW9uO1xuXG4gIC8vIFBlcmZvcm1hbmNlOiBvbmx5IGNvbXB1dGVyIG1hdGNoZXMgd2hlbiB0aGUgbWluTWF0Y2hDaGFyTGVuZ3RoID4gMVxuICAvLyBPUiBpZiBgaW5jbHVkZU1hdGNoZXNgIGlzIHRydWUuXG4gIGNvbnN0IGNvbXB1dGVNYXRjaGVzID0gbWluTWF0Y2hDaGFyTGVuZ3RoID4gMSB8fCBpbmNsdWRlTWF0Y2hlcztcbiAgLy8gQSBtYXNrIG9mIHRoZSBtYXRjaGVzLCB1c2VkIGZvciBidWlsZGluZyB0aGUgaW5kaWNlc1xuICBjb25zdCBtYXRjaE1hc2sgPSBjb21wdXRlTWF0Y2hlcyA/IEFycmF5KHRleHRMZW4pIDogW107XG5cbiAgbGV0IGluZGV4O1xuXG4gIC8vIEdldCBhbGwgZXhhY3QgbWF0Y2hlcywgaGVyZSBmb3Igc3BlZWQgdXBcbiAgd2hpbGUgKChpbmRleCA9IHRleHQuaW5kZXhPZihwYXR0ZXJuLCBiZXN0TG9jYXRpb24pKSA+IC0xKSB7XG4gICAgbGV0IHNjb3JlID0gY29tcHV0ZVNjb3JlJDEocGF0dGVybiwge1xuICAgICAgY3VycmVudExvY2F0aW9uOiBpbmRleCxcbiAgICAgIGV4cGVjdGVkTG9jYXRpb24sXG4gICAgICBkaXN0YW5jZSxcbiAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgfSk7XG5cbiAgICBjdXJyZW50VGhyZXNob2xkID0gTWF0aC5taW4oc2NvcmUsIGN1cnJlbnRUaHJlc2hvbGQpO1xuICAgIGJlc3RMb2NhdGlvbiA9IGluZGV4ICsgcGF0dGVybkxlbjtcblxuICAgIGlmIChjb21wdXRlTWF0Y2hlcykge1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgd2hpbGUgKGkgPCBwYXR0ZXJuTGVuKSB7XG4gICAgICAgIG1hdGNoTWFza1tpbmRleCArIGldID0gMTtcbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlc2V0IHRoZSBiZXN0IGxvY2F0aW9uXG4gIGJlc3RMb2NhdGlvbiA9IC0xO1xuXG4gIGxldCBsYXN0Qml0QXJyID0gW107XG4gIGxldCBmaW5hbFNjb3JlID0gMTtcbiAgbGV0IGJpbk1heCA9IHBhdHRlcm5MZW4gKyB0ZXh0TGVuO1xuXG4gIGNvbnN0IG1hc2sgPSAxIDw8IChwYXR0ZXJuTGVuIC0gMSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJuTGVuOyBpICs9IDEpIHtcbiAgICAvLyBTY2FuIGZvciB0aGUgYmVzdCBtYXRjaDsgZWFjaCBpdGVyYXRpb24gYWxsb3dzIGZvciBvbmUgbW9yZSBlcnJvci5cbiAgICAvLyBSdW4gYSBiaW5hcnkgc2VhcmNoIHRvIGRldGVybWluZSBob3cgZmFyIGZyb20gdGhlIG1hdGNoIGxvY2F0aW9uIHdlIGNhbiBzdHJheVxuICAgIC8vIGF0IHRoaXMgZXJyb3IgbGV2ZWwuXG4gICAgbGV0IGJpbk1pbiA9IDA7XG4gICAgbGV0IGJpbk1pZCA9IGJpbk1heDtcblxuICAgIHdoaWxlIChiaW5NaW4gPCBiaW5NaWQpIHtcbiAgICAgIGNvbnN0IHNjb3JlID0gY29tcHV0ZVNjb3JlJDEocGF0dGVybiwge1xuICAgICAgICBlcnJvcnM6IGksXG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbjogZXhwZWN0ZWRMb2NhdGlvbiArIGJpbk1pZCxcbiAgICAgICAgZXhwZWN0ZWRMb2NhdGlvbixcbiAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgICB9KTtcblxuICAgICAgaWYgKHNjb3JlIDw9IGN1cnJlbnRUaHJlc2hvbGQpIHtcbiAgICAgICAgYmluTWluID0gYmluTWlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmluTWF4ID0gYmluTWlkO1xuICAgICAgfVxuXG4gICAgICBiaW5NaWQgPSBNYXRoLmZsb29yKChiaW5NYXggLSBiaW5NaW4pIC8gMiArIGJpbk1pbik7XG4gICAgfVxuXG4gICAgLy8gVXNlIHRoZSByZXN1bHQgZnJvbSB0aGlzIGl0ZXJhdGlvbiBhcyB0aGUgbWF4aW11bSBmb3IgdGhlIG5leHQuXG4gICAgYmluTWF4ID0gYmluTWlkO1xuXG4gICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoMSwgZXhwZWN0ZWRMb2NhdGlvbiAtIGJpbk1pZCArIDEpO1xuICAgIGxldCBmaW5pc2ggPSBmaW5kQWxsTWF0Y2hlc1xuICAgICAgPyB0ZXh0TGVuXG4gICAgICA6IE1hdGgubWluKGV4cGVjdGVkTG9jYXRpb24gKyBiaW5NaWQsIHRleHRMZW4pICsgcGF0dGVybkxlbjtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIGJpdCBhcnJheVxuICAgIGxldCBiaXRBcnIgPSBBcnJheShmaW5pc2ggKyAyKTtcblxuICAgIGJpdEFycltmaW5pc2ggKyAxXSA9ICgxIDw8IGkpIC0gMTtcblxuICAgIGZvciAobGV0IGogPSBmaW5pc2g7IGogPj0gc3RhcnQ7IGogLT0gMSkge1xuICAgICAgbGV0IGN1cnJlbnRMb2NhdGlvbiA9IGogLSAxO1xuICAgICAgbGV0IGNoYXJNYXRjaCA9IHBhdHRlcm5BbHBoYWJldFt0ZXh0LmNoYXJBdChjdXJyZW50TG9jYXRpb24pXTtcblxuICAgICAgaWYgKGNvbXB1dGVNYXRjaGVzKSB7XG4gICAgICAgIC8vIFNwZWVkIHVwOiBxdWljayBib29sIHRvIGludCBjb252ZXJzaW9uIChpLmUsIGBjaGFyTWF0Y2ggPyAxIDogMGApXG4gICAgICAgIG1hdGNoTWFza1tjdXJyZW50TG9jYXRpb25dID0gKyEhY2hhck1hdGNoO1xuICAgICAgfVxuXG4gICAgICAvLyBGaXJzdCBwYXNzOiBleGFjdCBtYXRjaFxuICAgICAgYml0QXJyW2pdID0gKChiaXRBcnJbaiArIDFdIDw8IDEpIHwgMSkgJiBjaGFyTWF0Y2g7XG5cbiAgICAgIC8vIFN1YnNlcXVlbnQgcGFzc2VzOiBmdXp6eSBtYXRjaFxuICAgICAgaWYgKGkpIHtcbiAgICAgICAgYml0QXJyW2pdIHw9XG4gICAgICAgICAgKChsYXN0Qml0QXJyW2ogKyAxXSB8IGxhc3RCaXRBcnJbal0pIDw8IDEpIHwgMSB8IGxhc3RCaXRBcnJbaiArIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoYml0QXJyW2pdICYgbWFzaykge1xuICAgICAgICBmaW5hbFNjb3JlID0gY29tcHV0ZVNjb3JlJDEocGF0dGVybiwge1xuICAgICAgICAgIGVycm9yczogaSxcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb24sXG4gICAgICAgICAgZXhwZWN0ZWRMb2NhdGlvbixcbiAgICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgICBpZ25vcmVMb2NhdGlvblxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBUaGlzIG1hdGNoIHdpbGwgYWxtb3N0IGNlcnRhaW5seSBiZSBiZXR0ZXIgdGhhbiBhbnkgZXhpc3RpbmcgbWF0Y2guXG4gICAgICAgIC8vIEJ1dCBjaGVjayBhbnl3YXkuXG4gICAgICAgIGlmIChmaW5hbFNjb3JlIDw9IGN1cnJlbnRUaHJlc2hvbGQpIHtcbiAgICAgICAgICAvLyBJbmRlZWQgaXQgaXNcbiAgICAgICAgICBjdXJyZW50VGhyZXNob2xkID0gZmluYWxTY29yZTtcbiAgICAgICAgICBiZXN0TG9jYXRpb24gPSBjdXJyZW50TG9jYXRpb247XG5cbiAgICAgICAgICAvLyBBbHJlYWR5IHBhc3NlZCBgbG9jYCwgZG93bmhpbGwgZnJvbSBoZXJlIG9uIGluLlxuICAgICAgICAgIGlmIChiZXN0TG9jYXRpb24gPD0gZXhwZWN0ZWRMb2NhdGlvbikge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBXaGVuIHBhc3NpbmcgYGJlc3RMb2NhdGlvbmAsIGRvbid0IGV4Y2VlZCBvdXIgY3VycmVudCBkaXN0YW5jZSBmcm9tIGBleHBlY3RlZExvY2F0aW9uYC5cbiAgICAgICAgICBzdGFydCA9IE1hdGgubWF4KDEsIDIgKiBleHBlY3RlZExvY2F0aW9uIC0gYmVzdExvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vIGhvcGUgZm9yIGEgKGJldHRlcikgbWF0Y2ggYXQgZ3JlYXRlciBlcnJvciBsZXZlbHMuXG4gICAgY29uc3Qgc2NvcmUgPSBjb21wdXRlU2NvcmUkMShwYXR0ZXJuLCB7XG4gICAgICBlcnJvcnM6IGkgKyAxLFxuICAgICAgY3VycmVudExvY2F0aW9uOiBleHBlY3RlZExvY2F0aW9uLFxuICAgICAgZXhwZWN0ZWRMb2NhdGlvbixcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgaWdub3JlTG9jYXRpb25cbiAgICB9KTtcblxuICAgIGlmIChzY29yZSA+IGN1cnJlbnRUaHJlc2hvbGQpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgbGFzdEJpdEFyciA9IGJpdEFycjtcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBpc01hdGNoOiBiZXN0TG9jYXRpb24gPj0gMCxcbiAgICAvLyBDb3VudCBleGFjdCBtYXRjaGVzICh0aG9zZSB3aXRoIGEgc2NvcmUgb2YgMCkgdG8gYmUgXCJhbG1vc3RcIiBleGFjdFxuICAgIHNjb3JlOiBNYXRoLm1heCgwLjAwMSwgZmluYWxTY29yZSlcbiAgfTtcblxuICBpZiAoY29tcHV0ZU1hdGNoZXMpIHtcbiAgICBjb25zdCBpbmRpY2VzID0gY29udmVydE1hc2tUb0luZGljZXMobWF0Y2hNYXNrLCBtaW5NYXRjaENoYXJMZW5ndGgpO1xuICAgIGlmICghaW5kaWNlcy5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdC5pc01hdGNoID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpbmNsdWRlTWF0Y2hlcykge1xuICAgICAgcmVzdWx0LmluZGljZXMgPSBpbmRpY2VzO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0dGVybkFscGhhYmV0KHBhdHRlcm4pIHtcbiAgbGV0IG1hc2sgPSB7fTtcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gcGF0dGVybi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgIGNvbnN0IGNoYXIgPSBwYXR0ZXJuLmNoYXJBdChpKTtcbiAgICBtYXNrW2NoYXJdID0gKG1hc2tbY2hhcl0gfHwgMCkgfCAoMSA8PCAobGVuIC0gaSAtIDEpKTtcbiAgfVxuXG4gIHJldHVybiBtYXNrXG59XG5cbmNsYXNzIEJpdGFwU2VhcmNoIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcGF0dGVybixcbiAgICB7XG4gICAgICBsb2NhdGlvbiA9IENvbmZpZy5sb2NhdGlvbixcbiAgICAgIHRocmVzaG9sZCA9IENvbmZpZy50aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZSA9IENvbmZpZy5kaXN0YW5jZSxcbiAgICAgIGluY2x1ZGVNYXRjaGVzID0gQ29uZmlnLmluY2x1ZGVNYXRjaGVzLFxuICAgICAgZmluZEFsbE1hdGNoZXMgPSBDb25maWcuZmluZEFsbE1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGggPSBDb25maWcubWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgaXNDYXNlU2Vuc2l0aXZlID0gQ29uZmlnLmlzQ2FzZVNlbnNpdGl2ZSxcbiAgICAgIGlnbm9yZUxvY2F0aW9uID0gQ29uZmlnLmlnbm9yZUxvY2F0aW9uXG4gICAgfSA9IHt9XG4gICkge1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkLFxuICAgICAgZGlzdGFuY2UsXG4gICAgICBpbmNsdWRlTWF0Y2hlcyxcbiAgICAgIGZpbmRBbGxNYXRjaGVzLFxuICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaWdub3JlTG9jYXRpb25cbiAgICB9O1xuXG4gICAgdGhpcy5wYXR0ZXJuID0gaXNDYXNlU2Vuc2l0aXZlID8gcGF0dGVybiA6IHBhdHRlcm4udG9Mb3dlckNhc2UoKTtcblxuICAgIHRoaXMuY2h1bmtzID0gW107XG5cbiAgICBpZiAoIXRoaXMucGF0dGVybi5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGFkZENodW5rID0gKHBhdHRlcm4sIHN0YXJ0SW5kZXgpID0+IHtcbiAgICAgIHRoaXMuY2h1bmtzLnB1c2goe1xuICAgICAgICBwYXR0ZXJuLFxuICAgICAgICBhbHBoYWJldDogY3JlYXRlUGF0dGVybkFscGhhYmV0KHBhdHRlcm4pLFxuICAgICAgICBzdGFydEluZGV4XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgbGVuID0gdGhpcy5wYXR0ZXJuLmxlbmd0aDtcblxuICAgIGlmIChsZW4gPiBNQVhfQklUUykge1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgY29uc3QgcmVtYWluZGVyID0gbGVuICUgTUFYX0JJVFM7XG4gICAgICBjb25zdCBlbmQgPSBsZW4gLSByZW1haW5kZXI7XG5cbiAgICAgIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgICAgIGFkZENodW5rKHRoaXMucGF0dGVybi5zdWJzdHIoaSwgTUFYX0JJVFMpLCBpKTtcbiAgICAgICAgaSArPSBNQVhfQklUUztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlbWFpbmRlcikge1xuICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gbGVuIC0gTUFYX0JJVFM7XG4gICAgICAgIGFkZENodW5rKHRoaXMucGF0dGVybi5zdWJzdHIoc3RhcnRJbmRleCksIHN0YXJ0SW5kZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhZGRDaHVuayh0aGlzLnBhdHRlcm4sIDApO1xuICAgIH1cbiAgfVxuXG4gIHNlYXJjaEluKHRleHQpIHtcbiAgICBjb25zdCB7IGlzQ2FzZVNlbnNpdGl2ZSwgaW5jbHVkZU1hdGNoZXMgfSA9IHRoaXMub3B0aW9ucztcblxuICAgIGlmICghaXNDYXNlU2Vuc2l0aXZlKSB7XG4gICAgICB0ZXh0ID0gdGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8vIEV4YWN0IG1hdGNoXG4gICAgaWYgKHRoaXMucGF0dGVybiA9PT0gdGV4dCkge1xuICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgaXNNYXRjaDogdHJ1ZSxcbiAgICAgICAgc2NvcmU6IDBcbiAgICAgIH07XG5cbiAgICAgIGlmIChpbmNsdWRlTWF0Y2hlcykge1xuICAgICAgICByZXN1bHQuaW5kaWNlcyA9IFtbMCwgdGV4dC5sZW5ndGggLSAxXV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIHVzZSBCaXRhcCBhbGdvcml0aG1cbiAgICBjb25zdCB7XG4gICAgICBsb2NhdGlvbixcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgdGhyZXNob2xkLFxuICAgICAgZmluZEFsbE1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpZ25vcmVMb2NhdGlvblxuICAgIH0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBsZXQgYWxsSW5kaWNlcyA9IFtdO1xuICAgIGxldCB0b3RhbFNjb3JlID0gMDtcbiAgICBsZXQgaGFzTWF0Y2hlcyA9IGZhbHNlO1xuXG4gICAgdGhpcy5jaHVua3MuZm9yRWFjaCgoeyBwYXR0ZXJuLCBhbHBoYWJldCwgc3RhcnRJbmRleCB9KSA9PiB7XG4gICAgICBjb25zdCB7IGlzTWF0Y2gsIHNjb3JlLCBpbmRpY2VzIH0gPSBzZWFyY2godGV4dCwgcGF0dGVybiwgYWxwaGFiZXQsIHtcbiAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uICsgc3RhcnRJbmRleCxcbiAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgIHRocmVzaG9sZCxcbiAgICAgICAgZmluZEFsbE1hdGNoZXMsXG4gICAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCxcbiAgICAgICAgaW5jbHVkZU1hdGNoZXMsXG4gICAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgICB9KTtcblxuICAgICAgaWYgKGlzTWF0Y2gpIHtcbiAgICAgICAgaGFzTWF0Y2hlcyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRvdGFsU2NvcmUgKz0gc2NvcmU7XG5cbiAgICAgIGlmIChpc01hdGNoICYmIGluZGljZXMpIHtcbiAgICAgICAgYWxsSW5kaWNlcyA9IFsuLi5hbGxJbmRpY2VzLCAuLi5pbmRpY2VzXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGxldCByZXN1bHQgPSB7XG4gICAgICBpc01hdGNoOiBoYXNNYXRjaGVzLFxuICAgICAgc2NvcmU6IGhhc01hdGNoZXMgPyB0b3RhbFNjb3JlIC8gdGhpcy5jaHVua3MubGVuZ3RoIDogMVxuICAgIH07XG5cbiAgICBpZiAoaGFzTWF0Y2hlcyAmJiBpbmNsdWRlTWF0Y2hlcykge1xuICAgICAgcmVzdWx0LmluZGljZXMgPSBhbGxJbmRpY2VzO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG5jbGFzcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybjtcbiAgfVxuICBzdGF0aWMgaXNNdWx0aU1hdGNoKHBhdHRlcm4pIHtcbiAgICByZXR1cm4gZ2V0TWF0Y2gocGF0dGVybiwgdGhpcy5tdWx0aVJlZ2V4KVxuICB9XG4gIHN0YXRpYyBpc1NpbmdsZU1hdGNoKHBhdHRlcm4pIHtcbiAgICByZXR1cm4gZ2V0TWF0Y2gocGF0dGVybiwgdGhpcy5zaW5nbGVSZWdleClcbiAgfVxuICBzZWFyY2goLyp0ZXh0Ki8pIHt9XG59XG5cbmZ1bmN0aW9uIGdldE1hdGNoKHBhdHRlcm4sIGV4cCkge1xuICBjb25zdCBtYXRjaGVzID0gcGF0dGVybi5tYXRjaChleHApO1xuICByZXR1cm4gbWF0Y2hlcyA/IG1hdGNoZXNbMV0gOiBudWxsXG59XG5cbi8vIFRva2VuOiAnZmlsZVxuXG5jbGFzcyBFeGFjdE1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2V4YWN0J1xuICB9XG4gIHN0YXRpYyBnZXQgbXVsdGlSZWdleCgpIHtcbiAgICByZXR1cm4gL149XCIoLiopXCIkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9ePSguKikkL1xuICB9XG4gIHNlYXJjaCh0ZXh0KSB7XG4gICAgY29uc3QgaXNNYXRjaCA9IHRleHQgPT09IHRoaXMucGF0dGVybjtcblxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXM6IFswLCB0aGlzLnBhdHRlcm4ubGVuZ3RoIC0gMV1cbiAgICB9XG4gIH1cbn1cblxuLy8gVG9rZW46ICFmaXJlXG5cbmNsYXNzIEludmVyc2VFeGFjdE1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2ludmVyc2UtZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiFcIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL14hKC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpbmRleCA9IHRleHQuaW5kZXhPZih0aGlzLnBhdHRlcm4pO1xuICAgIGNvbnN0IGlzTWF0Y2ggPSBpbmRleCA9PT0gLTE7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIHNjb3JlOiBpc01hdGNoID8gMCA6IDEsXG4gICAgICBpbmRpY2VzOiBbMCwgdGV4dC5sZW5ndGggLSAxXVxuICAgIH1cbiAgfVxufVxuXG4vLyBUb2tlbjogXmZpbGVcblxuY2xhc3MgUHJlZml4RXhhY3RNYXRjaCBleHRlbmRzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICBzdXBlcihwYXR0ZXJuKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdwcmVmaXgtZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXlxcXlwiKC4qKVwiJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXlxcXiguKikkL1xuICB9XG4gIHNlYXJjaCh0ZXh0KSB7XG4gICAgY29uc3QgaXNNYXRjaCA9IHRleHQuc3RhcnRzV2l0aCh0aGlzLnBhdHRlcm4pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBzY29yZTogaXNNYXRjaCA/IDAgOiAxLFxuICAgICAgaW5kaWNlczogWzAsIHRoaXMucGF0dGVybi5sZW5ndGggLSAxXVxuICAgIH1cbiAgfVxufVxuXG4vLyBUb2tlbjogIV5maXJlXG5cbmNsYXNzIEludmVyc2VQcmVmaXhFeGFjdE1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2ludmVyc2UtcHJlZml4LWV4YWN0J1xuICB9XG4gIHN0YXRpYyBnZXQgbXVsdGlSZWdleCgpIHtcbiAgICByZXR1cm4gL14hXFxeXCIoLiopXCIkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eIVxcXiguKikkL1xuICB9XG4gIHNlYXJjaCh0ZXh0KSB7XG4gICAgY29uc3QgaXNNYXRjaCA9ICF0ZXh0LnN0YXJ0c1dpdGgodGhpcy5wYXR0ZXJuKTtcblxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXM6IFswLCB0ZXh0Lmxlbmd0aCAtIDFdXG4gICAgfVxuICB9XG59XG5cbi8vIFRva2VuOiAuZmlsZSRcblxuY2xhc3MgU3VmZml4RXhhY3RNYXRjaCBleHRlbmRzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICBzdXBlcihwYXR0ZXJuKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdzdWZmaXgtZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXlwiKC4qKVwiXFwkJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiguKilcXCQkL1xuICB9XG4gIHNlYXJjaCh0ZXh0KSB7XG4gICAgY29uc3QgaXNNYXRjaCA9IHRleHQuZW5kc1dpdGgodGhpcy5wYXR0ZXJuKTtcblxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXM6IFt0ZXh0Lmxlbmd0aCAtIHRoaXMucGF0dGVybi5sZW5ndGgsIHRleHQubGVuZ3RoIC0gMV1cbiAgICB9XG4gIH1cbn1cblxuLy8gVG9rZW46ICEuZmlsZSRcblxuY2xhc3MgSW52ZXJzZVN1ZmZpeEV4YWN0TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnaW52ZXJzZS1zdWZmaXgtZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiFcIiguKilcIlxcJCQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL14hKC4qKVxcJCQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpc01hdGNoID0gIXRleHQuZW5kc1dpdGgodGhpcy5wYXR0ZXJuKTtcbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIHNjb3JlOiBpc01hdGNoID8gMCA6IDEsXG4gICAgICBpbmRpY2VzOiBbMCwgdGV4dC5sZW5ndGggLSAxXVxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBGdXp6eU1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcGF0dGVybixcbiAgICB7XG4gICAgICBsb2NhdGlvbiA9IENvbmZpZy5sb2NhdGlvbixcbiAgICAgIHRocmVzaG9sZCA9IENvbmZpZy50aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZSA9IENvbmZpZy5kaXN0YW5jZSxcbiAgICAgIGluY2x1ZGVNYXRjaGVzID0gQ29uZmlnLmluY2x1ZGVNYXRjaGVzLFxuICAgICAgZmluZEFsbE1hdGNoZXMgPSBDb25maWcuZmluZEFsbE1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGggPSBDb25maWcubWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgaXNDYXNlU2Vuc2l0aXZlID0gQ29uZmlnLmlzQ2FzZVNlbnNpdGl2ZSxcbiAgICAgIGlnbm9yZUxvY2F0aW9uID0gQ29uZmlnLmlnbm9yZUxvY2F0aW9uXG4gICAgfSA9IHt9XG4gICkge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICAgIHRoaXMuX2JpdGFwU2VhcmNoID0gbmV3IEJpdGFwU2VhcmNoKHBhdHRlcm4sIHtcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkLFxuICAgICAgZGlzdGFuY2UsXG4gICAgICBpbmNsdWRlTWF0Y2hlcyxcbiAgICAgIGZpbmRBbGxNYXRjaGVzLFxuICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaWdub3JlTG9jYXRpb25cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdmdXp6eSdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eXCIoLiopXCIkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eKC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5fYml0YXBTZWFyY2guc2VhcmNoSW4odGV4dClcbiAgfVxufVxuXG4vLyBUb2tlbjogJ2ZpbGVcblxuY2xhc3MgSW5jbHVkZU1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2luY2x1ZGUnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXidcIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL14nKC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBsZXQgbG9jYXRpb24gPSAwO1xuICAgIGxldCBpbmRleDtcblxuICAgIGNvbnN0IGluZGljZXMgPSBbXTtcbiAgICBjb25zdCBwYXR0ZXJuTGVuID0gdGhpcy5wYXR0ZXJuLmxlbmd0aDtcblxuICAgIC8vIEdldCBhbGwgZXhhY3QgbWF0Y2hlc1xuICAgIHdoaWxlICgoaW5kZXggPSB0ZXh0LmluZGV4T2YodGhpcy5wYXR0ZXJuLCBsb2NhdGlvbikpID4gLTEpIHtcbiAgICAgIGxvY2F0aW9uID0gaW5kZXggKyBwYXR0ZXJuTGVuO1xuICAgICAgaW5kaWNlcy5wdXNoKFtpbmRleCwgbG9jYXRpb24gLSAxXSk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNNYXRjaCA9ICEhaW5kaWNlcy5sZW5ndGg7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIHNjb3JlOiBpc01hdGNoID8gMCA6IDEsXG4gICAgICBpbmRpY2VzXG4gICAgfVxuICB9XG59XG5cbi8vIFx1Mjc1N09yZGVyIGlzIGltcG9ydGFudC4gRE8gTk9UIENIQU5HRS5cbmNvbnN0IHNlYXJjaGVycyA9IFtcbiAgRXhhY3RNYXRjaCxcbiAgSW5jbHVkZU1hdGNoLFxuICBQcmVmaXhFeGFjdE1hdGNoLFxuICBJbnZlcnNlUHJlZml4RXhhY3RNYXRjaCxcbiAgSW52ZXJzZVN1ZmZpeEV4YWN0TWF0Y2gsXG4gIFN1ZmZpeEV4YWN0TWF0Y2gsXG4gIEludmVyc2VFeGFjdE1hdGNoLFxuICBGdXp6eU1hdGNoXG5dO1xuXG5jb25zdCBzZWFyY2hlcnNMZW4gPSBzZWFyY2hlcnMubGVuZ3RoO1xuXG4vLyBSZWdleCB0byBzcGxpdCBieSBzcGFjZXMsIGJ1dCBrZWVwIGFueXRoaW5nIGluIHF1b3RlcyB0b2dldGhlclxuY29uc3QgU1BBQ0VfUkUgPSAvICsoPz0oPzpbXlxcXCJdKlxcXCJbXlxcXCJdKlxcXCIpKlteXFxcIl0qJCkvO1xuY29uc3QgT1JfVE9LRU4gPSAnfCc7XG5cbi8vIFJldHVybiBhIDJEIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBxdWVyeSwgZm9yIHNpbXBsZXIgcGFyc2luZy5cbi8vIEV4YW1wbGU6XG4vLyBcIl5jb3JlIGdvJCB8IHJiJCB8IHB5JCB4eSRcIiA9PiBbW1wiXmNvcmVcIiwgXCJnbyRcIl0sIFtcInJiJFwiXSwgW1wicHkkXCIsIFwieHkkXCJdXVxuZnVuY3Rpb24gcGFyc2VRdWVyeShwYXR0ZXJuLCBvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoT1JfVE9LRU4pLm1hcCgoaXRlbSkgPT4ge1xuICAgIGxldCBxdWVyeSA9IGl0ZW1cbiAgICAgIC50cmltKClcbiAgICAgIC5zcGxpdChTUEFDRV9SRSlcbiAgICAgIC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0gJiYgISFpdGVtLnRyaW0oKSk7XG5cbiAgICBsZXQgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBxdWVyeS5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgY29uc3QgcXVlcnlJdGVtID0gcXVlcnlbaV07XG5cbiAgICAgIC8vIDEuIEhhbmRsZSBtdWx0aXBsZSBxdWVyeSBtYXRjaCAoaS5lLCBvbmNlIHRoYXQgYXJlIHF1b3RlZCwgbGlrZSBgXCJoZWxsbyB3b3JsZFwiYClcbiAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgbGV0IGlkeCA9IC0xO1xuICAgICAgd2hpbGUgKCFmb3VuZCAmJiArK2lkeCA8IHNlYXJjaGVyc0xlbikge1xuICAgICAgICBjb25zdCBzZWFyY2hlciA9IHNlYXJjaGVyc1tpZHhdO1xuICAgICAgICBsZXQgdG9rZW4gPSBzZWFyY2hlci5pc011bHRpTWF0Y2gocXVlcnlJdGVtKTtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKG5ldyBzZWFyY2hlcih0b2tlbiwgb3B0aW9ucykpO1xuICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMi4gSGFuZGxlIHNpbmdsZSBxdWVyeSBtYXRjaGVzIChpLmUsIG9uY2UgdGhhdCBhcmUgKm5vdCogcXVvdGVkKVxuICAgICAgaWR4ID0gLTE7XG4gICAgICB3aGlsZSAoKytpZHggPCBzZWFyY2hlcnNMZW4pIHtcbiAgICAgICAgY29uc3Qgc2VhcmNoZXIgPSBzZWFyY2hlcnNbaWR4XTtcbiAgICAgICAgbGV0IHRva2VuID0gc2VhcmNoZXIuaXNTaW5nbGVNYXRjaChxdWVyeUl0ZW0pO1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2gobmV3IHNlYXJjaGVyKHRva2VuLCBvcHRpb25zKSk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzXG4gIH0pXG59XG5cbi8vIFRoZXNlIGV4dGVuZGVkIG1hdGNoZXJzIGNhbiByZXR1cm4gYW4gYXJyYXkgb2YgbWF0Y2hlcywgYXMgb3Bwb3NlZFxuLy8gdG8gYSBzaW5nbCBtYXRjaFxuY29uc3QgTXVsdGlNYXRjaFNldCA9IG5ldyBTZXQoW0Z1enp5TWF0Y2gudHlwZSwgSW5jbHVkZU1hdGNoLnR5cGVdKTtcblxuLyoqXG4gKiBDb21tYW5kLWxpa2Ugc2VhcmNoaW5nXG4gKiA9PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogR2l2ZW4gbXVsdGlwbGUgc2VhcmNoIHRlcm1zIGRlbGltaXRlZCBieSBzcGFjZXMuZS5nLiBgXmpzY3JpcHQgLnB5dGhvbiQgcnVieSAhamF2YWAsXG4gKiBzZWFyY2ggaW4gYSBnaXZlbiB0ZXh0LlxuICpcbiAqIFNlYXJjaCBzeW50YXg6XG4gKlxuICogfCBUb2tlbiAgICAgICB8IE1hdGNoIHR5cGUgICAgICAgICAgICAgICAgIHwgRGVzY3JpcHRpb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAtLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfFxuICogfCBganNjcmlwdGAgICB8IGZ1enp5LW1hdGNoICAgICAgICAgICAgICAgIHwgSXRlbXMgdGhhdCBmdXp6eSBtYXRjaCBganNjcmlwdGAgICAgICAgfFxuICogfCBgPXNjaGVtZWAgICB8IGV4YWN0LW1hdGNoICAgICAgICAgICAgICAgIHwgSXRlbXMgdGhhdCBhcmUgYHNjaGVtZWAgICAgICAgICAgICAgICAgfFxuICogfCBgJ3B5dGhvbmAgICB8IGluY2x1ZGUtbWF0Y2ggICAgICAgICAgICAgIHwgSXRlbXMgdGhhdCBpbmNsdWRlIGBweXRob25gICAgICAgICAgICAgfFxuICogfCBgIXJ1YnlgICAgICB8IGludmVyc2UtZXhhY3QtbWF0Y2ggICAgICAgIHwgSXRlbXMgdGhhdCBkbyBub3QgaW5jbHVkZSBgcnVieWAgICAgICAgfFxuICogfCBgXmphdmFgICAgICB8IHByZWZpeC1leGFjdC1tYXRjaCAgICAgICAgIHwgSXRlbXMgdGhhdCBzdGFydCB3aXRoIGBqYXZhYCAgICAgICAgICAgfFxuICogfCBgIV5lYXJsYW5nYCB8IGludmVyc2UtcHJlZml4LWV4YWN0LW1hdGNoIHwgSXRlbXMgdGhhdCBkbyBub3Qgc3RhcnQgd2l0aCBgZWFybGFuZ2AgfFxuICogfCBgLmpzJGAgICAgICB8IHN1ZmZpeC1leGFjdC1tYXRjaCAgICAgICAgIHwgSXRlbXMgdGhhdCBlbmQgd2l0aCBgLmpzYCAgICAgICAgICAgICAgfFxuICogfCBgIS5nbyRgICAgICB8IGludmVyc2Utc3VmZml4LWV4YWN0LW1hdGNoIHwgSXRlbXMgdGhhdCBkbyBub3QgZW5kIHdpdGggYC5nb2AgICAgICAgfFxuICpcbiAqIEEgc2luZ2xlIHBpcGUgY2hhcmFjdGVyIGFjdHMgYXMgYW4gT1Igb3BlcmF0b3IuIEZvciBleGFtcGxlLCB0aGUgZm9sbG93aW5nXG4gKiBxdWVyeSBtYXRjaGVzIGVudHJpZXMgdGhhdCBzdGFydCB3aXRoIGBjb3JlYCBhbmQgZW5kIHdpdGggZWl0aGVyYGdvYCwgYHJiYCxcbiAqIG9yYHB5YC5cbiAqXG4gKiBgYGBcbiAqIF5jb3JlIGdvJCB8IHJiJCB8IHB5JFxuICogYGBgXG4gKi9cbmNsYXNzIEV4dGVuZGVkU2VhcmNoIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcGF0dGVybixcbiAgICB7XG4gICAgICBpc0Nhc2VTZW5zaXRpdmUgPSBDb25maWcuaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaW5jbHVkZU1hdGNoZXMgPSBDb25maWcuaW5jbHVkZU1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGggPSBDb25maWcubWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgaWdub3JlTG9jYXRpb24gPSBDb25maWcuaWdub3JlTG9jYXRpb24sXG4gICAgICBmaW5kQWxsTWF0Y2hlcyA9IENvbmZpZy5maW5kQWxsTWF0Y2hlcyxcbiAgICAgIGxvY2F0aW9uID0gQ29uZmlnLmxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkID0gQ29uZmlnLnRocmVzaG9sZCxcbiAgICAgIGRpc3RhbmNlID0gQ29uZmlnLmRpc3RhbmNlXG4gICAgfSA9IHt9XG4gICkge1xuICAgIHRoaXMucXVlcnkgPSBudWxsO1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIGlzQ2FzZVNlbnNpdGl2ZSxcbiAgICAgIGluY2x1ZGVNYXRjaGVzLFxuICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgZmluZEFsbE1hdGNoZXMsXG4gICAgICBpZ25vcmVMb2NhdGlvbixcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkLFxuICAgICAgZGlzdGFuY2VcbiAgICB9O1xuXG4gICAgdGhpcy5wYXR0ZXJuID0gaXNDYXNlU2Vuc2l0aXZlID8gcGF0dGVybiA6IHBhdHRlcm4udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcGFyc2VRdWVyeSh0aGlzLnBhdHRlcm4sIHRoaXMub3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgY29uZGl0aW9uKF8sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy51c2VFeHRlbmRlZFNlYXJjaFxuICB9XG5cbiAgc2VhcmNoSW4odGV4dCkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5xdWVyeTtcblxuICAgIGlmICghcXVlcnkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzTWF0Y2g6IGZhbHNlLFxuICAgICAgICBzY29yZTogMVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHsgaW5jbHVkZU1hdGNoZXMsIGlzQ2FzZVNlbnNpdGl2ZSB9ID0gdGhpcy5vcHRpb25zO1xuXG4gICAgdGV4dCA9IGlzQ2FzZVNlbnNpdGl2ZSA/IHRleHQgOiB0ZXh0LnRvTG93ZXJDYXNlKCk7XG5cbiAgICBsZXQgbnVtTWF0Y2hlcyA9IDA7XG4gICAgbGV0IGFsbEluZGljZXMgPSBbXTtcbiAgICBsZXQgdG90YWxTY29yZSA9IDA7XG5cbiAgICAvLyBPUnNcbiAgICBmb3IgKGxldCBpID0gMCwgcUxlbiA9IHF1ZXJ5Lmxlbmd0aDsgaSA8IHFMZW47IGkgKz0gMSkge1xuICAgICAgY29uc3Qgc2VhcmNoZXJzID0gcXVlcnlbaV07XG5cbiAgICAgIC8vIFJlc2V0IGluZGljZXNcbiAgICAgIGFsbEluZGljZXMubGVuZ3RoID0gMDtcbiAgICAgIG51bU1hdGNoZXMgPSAwO1xuXG4gICAgICAvLyBBTkRzXG4gICAgICBmb3IgKGxldCBqID0gMCwgcExlbiA9IHNlYXJjaGVycy5sZW5ndGg7IGogPCBwTGVuOyBqICs9IDEpIHtcbiAgICAgICAgY29uc3Qgc2VhcmNoZXIgPSBzZWFyY2hlcnNbal07XG4gICAgICAgIGNvbnN0IHsgaXNNYXRjaCwgaW5kaWNlcywgc2NvcmUgfSA9IHNlYXJjaGVyLnNlYXJjaCh0ZXh0KTtcblxuICAgICAgICBpZiAoaXNNYXRjaCkge1xuICAgICAgICAgIG51bU1hdGNoZXMgKz0gMTtcbiAgICAgICAgICB0b3RhbFNjb3JlICs9IHNjb3JlO1xuICAgICAgICAgIGlmIChpbmNsdWRlTWF0Y2hlcykge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHNlYXJjaGVyLmNvbnN0cnVjdG9yLnR5cGU7XG4gICAgICAgICAgICBpZiAoTXVsdGlNYXRjaFNldC5oYXModHlwZSkpIHtcbiAgICAgICAgICAgICAgYWxsSW5kaWNlcyA9IFsuLi5hbGxJbmRpY2VzLCAuLi5pbmRpY2VzXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFsbEluZGljZXMucHVzaChpbmRpY2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG90YWxTY29yZSA9IDA7XG4gICAgICAgICAgbnVtTWF0Y2hlcyA9IDA7XG4gICAgICAgICAgYWxsSW5kaWNlcy5sZW5ndGggPSAwO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT1IgY29uZGl0aW9uLCBzbyBpZiBUUlVFLCByZXR1cm5cbiAgICAgIGlmIChudW1NYXRjaGVzKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgaXNNYXRjaDogdHJ1ZSxcbiAgICAgICAgICBzY29yZTogdG90YWxTY29yZSAvIG51bU1hdGNoZXNcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoaW5jbHVkZU1hdGNoZXMpIHtcbiAgICAgICAgICByZXN1bHQuaW5kaWNlcyA9IGFsbEluZGljZXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm90aGluZyB3YXMgbWF0Y2hlZFxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoOiBmYWxzZSxcbiAgICAgIHNjb3JlOiAxXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IHJlZ2lzdGVyZWRTZWFyY2hlcnMgPSBbXTtcblxuZnVuY3Rpb24gcmVnaXN0ZXIoLi4uYXJncykge1xuICByZWdpc3RlcmVkU2VhcmNoZXJzLnB1c2goLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNlYXJjaGVyKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHJlZ2lzdGVyZWRTZWFyY2hlcnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICBsZXQgc2VhcmNoZXJDbGFzcyA9IHJlZ2lzdGVyZWRTZWFyY2hlcnNbaV07XG4gICAgaWYgKHNlYXJjaGVyQ2xhc3MuY29uZGl0aW9uKHBhdHRlcm4sIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gbmV3IHNlYXJjaGVyQ2xhc3MocGF0dGVybiwgb3B0aW9ucylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IEJpdGFwU2VhcmNoKHBhdHRlcm4sIG9wdGlvbnMpXG59XG5cbmNvbnN0IExvZ2ljYWxPcGVyYXRvciA9IHtcbiAgQU5EOiAnJGFuZCcsXG4gIE9SOiAnJG9yJ1xufTtcblxuY29uc3QgS2V5VHlwZSA9IHtcbiAgUEFUSDogJyRwYXRoJyxcbiAgUEFUVEVSTjogJyR2YWwnXG59O1xuXG5jb25zdCBpc0V4cHJlc3Npb24gPSAocXVlcnkpID0+XG4gICEhKHF1ZXJ5W0xvZ2ljYWxPcGVyYXRvci5BTkRdIHx8IHF1ZXJ5W0xvZ2ljYWxPcGVyYXRvci5PUl0pO1xuXG5jb25zdCBpc1BhdGggPSAocXVlcnkpID0+ICEhcXVlcnlbS2V5VHlwZS5QQVRIXTtcblxuY29uc3QgaXNMZWFmID0gKHF1ZXJ5KSA9PlxuICAhaXNBcnJheShxdWVyeSkgJiYgaXNPYmplY3QocXVlcnkpICYmICFpc0V4cHJlc3Npb24ocXVlcnkpO1xuXG5jb25zdCBjb252ZXJ0VG9FeHBsaWNpdCA9IChxdWVyeSkgPT4gKHtcbiAgW0xvZ2ljYWxPcGVyYXRvci5BTkRdOiBPYmplY3Qua2V5cyhxdWVyeSkubWFwKChrZXkpID0+ICh7XG4gICAgW2tleV06IHF1ZXJ5W2tleV1cbiAgfSkpXG59KTtcblxuLy8gV2hlbiBgYXV0b2AgaXMgYHRydWVgLCB0aGUgcGFyc2UgZnVuY3Rpb24gd2lsbCBpbmZlciBhbmQgaW5pdGlhbGl6ZSBhbmQgYWRkXG4vLyB0aGUgYXBwcm9wcmlhdGUgYFNlYXJjaGVyYCBpbnN0YW5jZVxuZnVuY3Rpb24gcGFyc2UocXVlcnksIG9wdGlvbnMsIHsgYXV0byA9IHRydWUgfSA9IHt9KSB7XG4gIGNvbnN0IG5leHQgPSAocXVlcnkpID0+IHtcbiAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKHF1ZXJ5KTtcblxuICAgIGNvbnN0IGlzUXVlcnlQYXRoID0gaXNQYXRoKHF1ZXJ5KTtcblxuICAgIGlmICghaXNRdWVyeVBhdGggJiYga2V5cy5sZW5ndGggPiAxICYmICFpc0V4cHJlc3Npb24ocXVlcnkpKSB7XG4gICAgICByZXR1cm4gbmV4dChjb252ZXJ0VG9FeHBsaWNpdChxdWVyeSkpXG4gICAgfVxuXG4gICAgaWYgKGlzTGVhZihxdWVyeSkpIHtcbiAgICAgIGNvbnN0IGtleSA9IGlzUXVlcnlQYXRoID8gcXVlcnlbS2V5VHlwZS5QQVRIXSA6IGtleXNbMF07XG5cbiAgICAgIGNvbnN0IHBhdHRlcm4gPSBpc1F1ZXJ5UGF0aCA/IHF1ZXJ5W0tleVR5cGUuUEFUVEVSTl0gOiBxdWVyeVtrZXldO1xuXG4gICAgICBpZiAoIWlzU3RyaW5nKHBhdHRlcm4pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihMT0dJQ0FMX1NFQVJDSF9JTlZBTElEX1FVRVJZX0ZPUl9LRVkoa2V5KSlcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb2JqID0ge1xuICAgICAgICBrZXlJZDogY3JlYXRlS2V5SWQoa2V5KSxcbiAgICAgICAgcGF0dGVyblxuICAgICAgfTtcblxuICAgICAgaWYgKGF1dG8pIHtcbiAgICAgICAgb2JqLnNlYXJjaGVyID0gY3JlYXRlU2VhcmNoZXIocGF0dGVybiwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmpcbiAgICB9XG5cbiAgICBsZXQgbm9kZSA9IHtcbiAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgIG9wZXJhdG9yOiBrZXlzWzBdXG4gICAgfTtcblxuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHF1ZXJ5W2tleV07XG5cbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKG5leHQoaXRlbSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBub2RlXG4gIH07XG5cbiAgaWYgKCFpc0V4cHJlc3Npb24ocXVlcnkpKSB7XG4gICAgcXVlcnkgPSBjb252ZXJ0VG9FeHBsaWNpdChxdWVyeSk7XG4gIH1cblxuICByZXR1cm4gbmV4dChxdWVyeSlcbn1cblxuLy8gUHJhY3RpY2FsIHNjb3JpbmcgZnVuY3Rpb25cbmZ1bmN0aW9uIGNvbXB1dGVTY29yZShcbiAgcmVzdWx0cyxcbiAgeyBpZ25vcmVGaWVsZE5vcm0gPSBDb25maWcuaWdub3JlRmllbGROb3JtIH1cbikge1xuICByZXN1bHRzLmZvckVhY2goKHJlc3VsdCkgPT4ge1xuICAgIGxldCB0b3RhbFNjb3JlID0gMTtcblxuICAgIHJlc3VsdC5tYXRjaGVzLmZvckVhY2goKHsga2V5LCBub3JtLCBzY29yZSB9KSA9PiB7XG4gICAgICBjb25zdCB3ZWlnaHQgPSBrZXkgPyBrZXkud2VpZ2h0IDogbnVsbDtcblxuICAgICAgdG90YWxTY29yZSAqPSBNYXRoLnBvdyhcbiAgICAgICAgc2NvcmUgPT09IDAgJiYgd2VpZ2h0ID8gTnVtYmVyLkVQU0lMT04gOiBzY29yZSxcbiAgICAgICAgKHdlaWdodCB8fCAxKSAqIChpZ25vcmVGaWVsZE5vcm0gPyAxIDogbm9ybSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICByZXN1bHQuc2NvcmUgPSB0b3RhbFNjb3JlO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtTWF0Y2hlcyhyZXN1bHQsIGRhdGEpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IHJlc3VsdC5tYXRjaGVzO1xuICBkYXRhLm1hdGNoZXMgPSBbXTtcblxuICBpZiAoIWlzRGVmaW5lZChtYXRjaGVzKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgbWF0Y2hlcy5mb3JFYWNoKChtYXRjaCkgPT4ge1xuICAgIGlmICghaXNEZWZpbmVkKG1hdGNoLmluZGljZXMpIHx8ICFtYXRjaC5pbmRpY2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgeyBpbmRpY2VzLCB2YWx1ZSB9ID0gbWF0Y2g7XG5cbiAgICBsZXQgb2JqID0ge1xuICAgICAgaW5kaWNlcyxcbiAgICAgIHZhbHVlXG4gICAgfTtcblxuICAgIGlmIChtYXRjaC5rZXkpIHtcbiAgICAgIG9iai5rZXkgPSBtYXRjaC5rZXkuc3JjO1xuICAgIH1cblxuICAgIGlmIChtYXRjaC5pZHggPiAtMSkge1xuICAgICAgb2JqLnJlZkluZGV4ID0gbWF0Y2guaWR4O1xuICAgIH1cblxuICAgIGRhdGEubWF0Y2hlcy5wdXNoKG9iaik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TY29yZShyZXN1bHQsIGRhdGEpIHtcbiAgZGF0YS5zY29yZSA9IHJlc3VsdC5zY29yZTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0KFxuICByZXN1bHRzLFxuICBkb2NzLFxuICB7XG4gICAgaW5jbHVkZU1hdGNoZXMgPSBDb25maWcuaW5jbHVkZU1hdGNoZXMsXG4gICAgaW5jbHVkZVNjb3JlID0gQ29uZmlnLmluY2x1ZGVTY29yZVxuICB9ID0ge31cbikge1xuICBjb25zdCB0cmFuc2Zvcm1lcnMgPSBbXTtcblxuICBpZiAoaW5jbHVkZU1hdGNoZXMpIHRyYW5zZm9ybWVycy5wdXNoKHRyYW5zZm9ybU1hdGNoZXMpO1xuICBpZiAoaW5jbHVkZVNjb3JlKSB0cmFuc2Zvcm1lcnMucHVzaCh0cmFuc2Zvcm1TY29yZSk7XG5cbiAgcmV0dXJuIHJlc3VsdHMubWFwKChyZXN1bHQpID0+IHtcbiAgICBjb25zdCB7IGlkeCB9ID0gcmVzdWx0O1xuXG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIGl0ZW06IGRvY3NbaWR4XSxcbiAgICAgIHJlZkluZGV4OiBpZHhcbiAgICB9O1xuXG4gICAgaWYgKHRyYW5zZm9ybWVycy5sZW5ndGgpIHtcbiAgICAgIHRyYW5zZm9ybWVycy5mb3JFYWNoKCh0cmFuc2Zvcm1lcikgPT4ge1xuICAgICAgICB0cmFuc2Zvcm1lcihyZXN1bHQsIGRhdGEpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFcbiAgfSlcbn1cblxuY2xhc3MgRnVzZSB7XG4gIGNvbnN0cnVjdG9yKGRvY3MsIG9wdGlvbnMgPSB7fSwgaW5kZXgpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB7IC4uLkNvbmZpZywgLi4ub3B0aW9ucyB9O1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5vcHRpb25zLnVzZUV4dGVuZGVkU2VhcmNoICYmXG4gICAgICAhdHJ1ZVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKEVYVEVOREVEX1NFQVJDSF9VTkFWQUlMQUJMRSlcbiAgICB9XG5cbiAgICB0aGlzLl9rZXlTdG9yZSA9IG5ldyBLZXlTdG9yZSh0aGlzLm9wdGlvbnMua2V5cyk7XG5cbiAgICB0aGlzLnNldENvbGxlY3Rpb24oZG9jcywgaW5kZXgpO1xuICB9XG5cbiAgc2V0Q29sbGVjdGlvbihkb2NzLCBpbmRleCkge1xuICAgIHRoaXMuX2RvY3MgPSBkb2NzO1xuXG4gICAgaWYgKGluZGV4ICYmICEoaW5kZXggaW5zdGFuY2VvZiBGdXNlSW5kZXgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoSU5DT1JSRUNUX0lOREVYX1RZUEUpXG4gICAgfVxuXG4gICAgdGhpcy5fbXlJbmRleCA9XG4gICAgICBpbmRleCB8fFxuICAgICAgY3JlYXRlSW5kZXgodGhpcy5vcHRpb25zLmtleXMsIHRoaXMuX2RvY3MsIHtcbiAgICAgICAgZ2V0Rm46IHRoaXMub3B0aW9ucy5nZXRGbixcbiAgICAgICAgZmllbGROb3JtV2VpZ2h0OiB0aGlzLm9wdGlvbnMuZmllbGROb3JtV2VpZ2h0XG4gICAgICB9KTtcbiAgfVxuXG4gIGFkZChkb2MpIHtcbiAgICBpZiAoIWlzRGVmaW5lZChkb2MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9kb2NzLnB1c2goZG9jKTtcbiAgICB0aGlzLl9teUluZGV4LmFkZChkb2MpO1xuICB9XG5cbiAgcmVtb3ZlKHByZWRpY2F0ZSA9ICgvKiBkb2MsIGlkeCAqLykgPT4gZmFsc2UpIHtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5fZG9jcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgY29uc3QgZG9jID0gdGhpcy5fZG9jc1tpXTtcbiAgICAgIGlmIChwcmVkaWNhdGUoZG9jLCBpKSkge1xuICAgICAgICB0aGlzLnJlbW92ZUF0KGkpO1xuICAgICAgICBpIC09IDE7XG4gICAgICAgIGxlbiAtPSAxO1xuXG4gICAgICAgIHJlc3VsdHMucHVzaChkb2MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzXG4gIH1cblxuICByZW1vdmVBdChpZHgpIHtcbiAgICB0aGlzLl9kb2NzLnNwbGljZShpZHgsIDEpO1xuICAgIHRoaXMuX215SW5kZXgucmVtb3ZlQXQoaWR4KTtcbiAgfVxuXG4gIGdldEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLl9teUluZGV4XG4gIH1cblxuICBzZWFyY2gocXVlcnksIHsgbGltaXQgPSAtMSB9ID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBpbmNsdWRlTWF0Y2hlcyxcbiAgICAgIGluY2x1ZGVTY29yZSxcbiAgICAgIHNob3VsZFNvcnQsXG4gICAgICBzb3J0Rm4sXG4gICAgICBpZ25vcmVGaWVsZE5vcm1cbiAgICB9ID0gdGhpcy5vcHRpb25zO1xuXG4gICAgbGV0IHJlc3VsdHMgPSBpc1N0cmluZyhxdWVyeSlcbiAgICAgID8gaXNTdHJpbmcodGhpcy5fZG9jc1swXSlcbiAgICAgICAgPyB0aGlzLl9zZWFyY2hTdHJpbmdMaXN0KHF1ZXJ5KVxuICAgICAgICA6IHRoaXMuX3NlYXJjaE9iamVjdExpc3QocXVlcnkpXG4gICAgICA6IHRoaXMuX3NlYXJjaExvZ2ljYWwocXVlcnkpO1xuXG4gICAgY29tcHV0ZVNjb3JlKHJlc3VsdHMsIHsgaWdub3JlRmllbGROb3JtIH0pO1xuXG4gICAgaWYgKHNob3VsZFNvcnQpIHtcbiAgICAgIHJlc3VsdHMuc29ydChzb3J0Rm4pO1xuICAgIH1cblxuICAgIGlmIChpc051bWJlcihsaW1pdCkgJiYgbGltaXQgPiAtMSkge1xuICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc2xpY2UoMCwgbGltaXQpO1xuICAgIH1cblxuICAgIHJldHVybiBmb3JtYXQocmVzdWx0cywgdGhpcy5fZG9jcywge1xuICAgICAgaW5jbHVkZU1hdGNoZXMsXG4gICAgICBpbmNsdWRlU2NvcmVcbiAgICB9KVxuICB9XG5cbiAgX3NlYXJjaFN0cmluZ0xpc3QocXVlcnkpIHtcbiAgICBjb25zdCBzZWFyY2hlciA9IGNyZWF0ZVNlYXJjaGVyKHF1ZXJ5LCB0aGlzLm9wdGlvbnMpO1xuICAgIGNvbnN0IHsgcmVjb3JkcyB9ID0gdGhpcy5fbXlJbmRleDtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgZXZlcnkgc3RyaW5nIGluIHRoZSBpbmRleFxuICAgIHJlY29yZHMuZm9yRWFjaCgoeyB2OiB0ZXh0LCBpOiBpZHgsIG46IG5vcm0gfSkgPT4ge1xuICAgICAgaWYgKCFpc0RlZmluZWQodGV4dCkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgaXNNYXRjaCwgc2NvcmUsIGluZGljZXMgfSA9IHNlYXJjaGVyLnNlYXJjaEluKHRleHQpO1xuXG4gICAgICBpZiAoaXNNYXRjaCkge1xuICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgIGl0ZW06IHRleHQsXG4gICAgICAgICAgaWR4LFxuICAgICAgICAgIG1hdGNoZXM6IFt7IHNjb3JlLCB2YWx1ZTogdGV4dCwgbm9ybSwgaW5kaWNlcyB9XVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHRzXG4gIH1cblxuICBfc2VhcmNoTG9naWNhbChxdWVyeSkge1xuXG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IHBhcnNlKHF1ZXJ5LCB0aGlzLm9wdGlvbnMpO1xuXG4gICAgY29uc3QgZXZhbHVhdGUgPSAobm9kZSwgaXRlbSwgaWR4KSA9PiB7XG4gICAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgY29uc3QgeyBrZXlJZCwgc2VhcmNoZXIgfSA9IG5vZGU7XG5cbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHRoaXMuX2ZpbmRNYXRjaGVzKHtcbiAgICAgICAgICBrZXk6IHRoaXMuX2tleVN0b3JlLmdldChrZXlJZCksXG4gICAgICAgICAgdmFsdWU6IHRoaXMuX215SW5kZXguZ2V0VmFsdWVGb3JJdGVtQXRLZXlJZChpdGVtLCBrZXlJZCksXG4gICAgICAgICAgc2VhcmNoZXJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZHgsXG4gICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgIG1hdGNoZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW11cbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGV2YWx1YXRlKGNoaWxkLCBpdGVtLCBpZHgpO1xuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgIHJlcy5wdXNoKC4uLnJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5vcGVyYXRvciA9PT0gTG9naWNhbE9wZXJhdG9yLkFORCkge1xuICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzXG4gICAgfTtcblxuICAgIGNvbnN0IHJlY29yZHMgPSB0aGlzLl9teUluZGV4LnJlY29yZHM7XG4gICAgY29uc3QgcmVzdWx0TWFwID0ge307XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gICAgcmVjb3Jkcy5mb3JFYWNoKCh7ICQ6IGl0ZW0sIGk6IGlkeCB9KSA9PiB7XG4gICAgICBpZiAoaXNEZWZpbmVkKGl0ZW0pKSB7XG4gICAgICAgIGxldCBleHBSZXN1bHRzID0gZXZhbHVhdGUoZXhwcmVzc2lvbiwgaXRlbSwgaWR4KTtcblxuICAgICAgICBpZiAoZXhwUmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBEZWR1cGUgd2hlbiBhZGRpbmdcbiAgICAgICAgICBpZiAoIXJlc3VsdE1hcFtpZHhdKSB7XG4gICAgICAgICAgICByZXN1bHRNYXBbaWR4XSA9IHsgaWR4LCBpdGVtLCBtYXRjaGVzOiBbXSB9O1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdE1hcFtpZHhdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwUmVzdWx0cy5mb3JFYWNoKCh7IG1hdGNoZXMgfSkgPT4ge1xuICAgICAgICAgICAgcmVzdWx0TWFwW2lkeF0ubWF0Y2hlcy5wdXNoKC4uLm1hdGNoZXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0c1xuICB9XG5cbiAgX3NlYXJjaE9iamVjdExpc3QocXVlcnkpIHtcbiAgICBjb25zdCBzZWFyY2hlciA9IGNyZWF0ZVNlYXJjaGVyKHF1ZXJ5LCB0aGlzLm9wdGlvbnMpO1xuICAgIGNvbnN0IHsga2V5cywgcmVjb3JkcyB9ID0gdGhpcy5fbXlJbmRleDtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICAvLyBMaXN0IGlzIEFycmF5PE9iamVjdD5cbiAgICByZWNvcmRzLmZvckVhY2goKHsgJDogaXRlbSwgaTogaWR4IH0pID0+IHtcbiAgICAgIGlmICghaXNEZWZpbmVkKGl0ZW0pKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBsZXQgbWF0Y2hlcyA9IFtdO1xuXG4gICAgICAvLyBJdGVyYXRlIG92ZXIgZXZlcnkga2V5IChpLmUsIHBhdGgpLCBhbmQgZmV0Y2ggdGhlIHZhbHVlIGF0IHRoYXQga2V5XG4gICAgICBrZXlzLmZvckVhY2goKGtleSwga2V5SW5kZXgpID0+IHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKFxuICAgICAgICAgIC4uLnRoaXMuX2ZpbmRNYXRjaGVzKHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlOiBpdGVtW2tleUluZGV4XSxcbiAgICAgICAgICAgIHNlYXJjaGVyXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAobWF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICBpZHgsXG4gICAgICAgICAgaXRlbSxcbiAgICAgICAgICBtYXRjaGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfVxuICBfZmluZE1hdGNoZXMoeyBrZXksIHZhbHVlLCBzZWFyY2hlciB9KSB7XG4gICAgaWYgKCFpc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICByZXR1cm4gW11cbiAgICB9XG5cbiAgICBsZXQgbWF0Y2hlcyA9IFtdO1xuXG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZS5mb3JFYWNoKCh7IHY6IHRleHQsIGk6IGlkeCwgbjogbm9ybSB9KSA9PiB7XG4gICAgICAgIGlmICghaXNEZWZpbmVkKHRleHQpKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGlzTWF0Y2gsIHNjb3JlLCBpbmRpY2VzIH0gPSBzZWFyY2hlci5zZWFyY2hJbih0ZXh0KTtcblxuICAgICAgICBpZiAoaXNNYXRjaCkge1xuICAgICAgICAgIG1hdGNoZXMucHVzaCh7XG4gICAgICAgICAgICBzY29yZSxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlOiB0ZXh0LFxuICAgICAgICAgICAgaWR4LFxuICAgICAgICAgICAgbm9ybSxcbiAgICAgICAgICAgIGluZGljZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHsgdjogdGV4dCwgbjogbm9ybSB9ID0gdmFsdWU7XG5cbiAgICAgIGNvbnN0IHsgaXNNYXRjaCwgc2NvcmUsIGluZGljZXMgfSA9IHNlYXJjaGVyLnNlYXJjaEluKHRleHQpO1xuXG4gICAgICBpZiAoaXNNYXRjaCkge1xuICAgICAgICBtYXRjaGVzLnB1c2goeyBzY29yZSwga2V5LCB2YWx1ZTogdGV4dCwgbm9ybSwgaW5kaWNlcyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2hlc1xuICB9XG59XG5cbkZ1c2UudmVyc2lvbiA9ICc3LjAuMCc7XG5GdXNlLmNyZWF0ZUluZGV4ID0gY3JlYXRlSW5kZXg7XG5GdXNlLnBhcnNlSW5kZXggPSBwYXJzZUluZGV4O1xuRnVzZS5jb25maWcgPSBDb25maWc7XG5cbntcbiAgRnVzZS5wYXJzZVF1ZXJ5ID0gcGFyc2U7XG59XG5cbntcbiAgcmVnaXN0ZXIoRXh0ZW5kZWRTZWFyY2gpO1xufVxuXG5leHBvcnQgeyBGdXNlIGFzIGRlZmF1bHQgfTtcbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBLG1EQUFBQSxTQUFBO0FBVUEsUUFBSSxrQkFBa0I7QUFHdEIsUUFBSSxNQUFNLElBQUk7QUFHZCxRQUFJLFlBQVk7QUFHaEIsUUFBSSxTQUFTO0FBR2IsUUFBSSxhQUFhO0FBR2pCLFFBQUksYUFBYTtBQUdqQixRQUFJLFlBQVk7QUFHaEIsUUFBSSxlQUFlO0FBR25CLFFBQUksYUFBYSxPQUFPLFVBQVUsWUFBWSxVQUFVLE9BQU8sV0FBVyxVQUFVO0FBR3BG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UUFBSSxLQUFLLFlBQVk7QUFDbkIsb0JBQWMsS0FBSyxVQUFVO0FBQUEsSUFDL0I7QUFBQSxFQUNGO0FBRUY7OztBRjdPQSxJQUFxQixxQkFBckIsY0FBZ0Qsd0JBQU87QUFBQSxFQUdyRCxNQUFNLFNBQVM7QUFDYixVQUFNLEtBQUssYUFBYTtBQUV4QixTQUFLLGNBQWMsSUFBSSx3QkFBd0IsS0FBSyxLQUFLLElBQUksQ0FBQztBQUU5RCxTQUFLLGFBQWEsV0FBVyxVQUFRLElBQUksaUJBQWlCLE1BQU0sSUFBSSxDQUFDO0FBRXJFLFNBQUssV0FBVztBQUFBLE1BQ2QsSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sVUFBVSxNQUFNO0FBQ2QsYUFBSyxJQUFJLFVBQVUsYUFBYSxLQUFLLEVBQUUsYUFBYTtBQUFBLFVBQ2xELE1BQU07QUFBQSxVQUNOLE9BQU87QUFBQSxVQUNQLFFBQVE7QUFBQSxRQUNWLENBQUM7QUFBQSxNQUNIO0FBQUEsSUFDRixDQUFDO0FBR0QsU0FBSztBQUFBLE1BQ0gsT0FBTyxZQUFZLE1BQU0sUUFBUSxJQUFJLGFBQWEsR0FBRyxJQUFJLEtBQUssR0FBSTtBQUFBLElBQ3BFO0FBQUEsRUFDRjtBQUFBLEVBRUEsV0FBVztBQUdULFNBQUssSUFBSSxVQUFVLG1CQUFtQixTQUFTO0FBQUEsRUFDakQ7QUFBQSxFQUVBLE1BQU0sZUFBZTtBQUNuQixTQUFLLFdBQVcsT0FBTyxPQUFPLENBQUMsR0FBRyxrQkFBa0IsTUFBTSxLQUFLLFNBQVMsQ0FBQztBQUFBLEVBRTNFO0FBQUEsRUFFQSxNQUFNLGVBQWU7QUFDbkIsVUFBTSxLQUFLLFNBQVMsS0FBSyxRQUFRO0FBQUEsRUFDbkM7QUFBQSxFQUNBLE1BQU0sZUFBZTtBQUNuQixTQUFLLElBQUksVUFBVSxtQkFBbUIsU0FBUztBQUUvQyxVQUFNLEtBQUssSUFBSSxVQUFVLGFBQWEsS0FBSyxFQUFFLGFBQWE7QUFBQSxNQUN4RCxNQUFNO0FBQUEsTUFDTixRQUFRO0FBQUEsSUFDVixDQUFDO0FBRUQsU0FBSyxJQUFJLFVBQVU7QUFBQSxNQUNqQixLQUFLLElBQUksVUFBVSxnQkFBZ0IsU0FBUyxFQUFFLENBQUM7QUFBQSxJQUNqRDtBQUFBLEVBQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBT0Y7IiwKICAibmFtZXMiOiBbIm1vZHVsZSIsICJkZWJvdW5jZSIsICJpc09iamVjdCIsICJyZXN1bHQiLCAiaXNPYmplY3RMaWtlIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAib2JqIiwgInBhdGgiLCAibm9ybSIsICJ2YWx1ZSIsICJzY29yZSIsICJwYXR0ZXJuIiwgInJlc3VsdCIsICJpdGVtIiwgInNlYXJjaGVycyIsICJxdWVyeSIsICJkZWJvdW5jZSIsICJub3RlUGF0aCIsICJmaWxlIl0KfQo=
